diff -u libmagic.orig/apprentice.c libmagic/apprentice.c
--- libmagic.orig/apprentice.c	2016-01-25 11:17:38.141978563 +0800
+++ libmagic/apprentice.c	2016-01-25 11:19:37.409347842 +0800
@@ -29,6 +29,8 @@
  * apprentice - make one pass through /etc/magic, learning its secrets.
  */
 
+#include "php.h"
+
 #include "file.h"
 
 #ifndef	lint
@@ -36,18 +38,30 @@
 #endif	/* lint */
 
 #include "magic.h"
+#include "patchlevel.h"
 #include <stdlib.h>
-#ifdef HAVE_UNISTD_H
+
+#if defined(__hpux) && !defined(HAVE_STRTOULL)
+#if SIZEOF_LONG == 8
+# define strtoull strtoul
+#else
+# define strtoull __strtoull
+#endif
+#endif
+
+#ifdef PHP_WIN32
+#include "win32/unistd.h"
+#if _MSC_VER <= 1300
+# include "win32/php_strtoi64.h"
+#endif
+#define strtoull _strtoui64
+#else
 #include <unistd.h>
 #endif
 #include <string.h>
 #include <assert.h>
 #include <ctype.h>
 #include <fcntl.h>
-#ifdef QUICK
-#include <sys/mman.h>
-#endif
-#include <dirent.h>
 
 #define	EATAB {while (isascii((unsigned char) *l) && \
 		      isspace((unsigned char) *l))  ++l;}
@@ -148,38 +162,7 @@
 	{ NULL, 0, NULL }
 };
 
-#ifdef COMPILE_ONLY
-
-int main(int, char *[]);
-
-int
-main(int argc, char *argv[])
-{
-	int ret;
-	struct magic_set *ms;
-	char *progname;
-
-	if ((progname = strrchr(argv[0], '/')) != NULL)
-		progname++;
-	else
-		progname = argv[0];
-
-	if (argc != 2) {
-		(void)fprintf(stderr, "Usage: %s file\n", progname);
-		return 1;
-	}
-
-	if ((ms = magic_open(MAGIC_CHECK)) == NULL) {
-		(void)fprintf(stderr, "%s: %s\n", progname, strerror(errno));
-		return 1;
-	}
-	ret = magic_compile(ms, argv[1]) == -1 ? 1 : 0;
-	if (ret == 1)
-		(void)fprintf(stderr, "%s: %s\n", progname, magic_error(ms));
-	magic_close(ms);
-	return ret;
-}
-#endif /* COMPILE_ONLY */
+#include "../data_file.c"
 
 struct type_tbl_s {
 	const char name[16];
@@ -261,6 +244,10 @@
 # undef XX
 # undef XX_NULL
 
+#ifndef S_ISDIR
+#define S_ISDIR(mode) ((mode) & _S_IFDIR)
+#endif
+
 private int
 get_type(const struct type_tbl_s *tbl, const char *l, const char **t)
 {
@@ -384,7 +371,7 @@
 {
 	struct mlist *ml;
 
-	if ((ml = CAST(struct mlist *, malloc(sizeof(*ml)))) == NULL)
+	if ((ml = CAST(struct mlist *, emalloc(sizeof(*ml)))) == NULL)
 		return -1;
 
 	ml->map = idx == 0 ? map : NULL;
@@ -422,12 +409,13 @@
 		return apprentice_compile(ms, map, fn);
 	}
 
-#ifndef COMPILE_ONLY
 	map = apprentice_map(ms, fn);
 	if (map == NULL) {
-		if (ms->flags & MAGIC_CHECK)
-			file_magwarn(ms, "using regular magic file `%s'", fn);
-		map = apprentice_load(ms, fn, action);
+		if (fn) {
+			if (ms->flags & MAGIC_CHECK)
+				file_magwarn(ms, "using regular magic file `%s'", fn);
+			map = apprentice_load(ms, fn, action);
+		}
 		if (map == NULL)
 			return -1;
 	}
@@ -450,7 +438,6 @@
 	}
 	
 	return 0;
-#endif /* COMPILE_ONLY */
 }
 
 protected void
@@ -461,10 +448,16 @@
 		return;
 	for (i = 0; i < MAGIC_SETS; i++)
 		mlist_free(ms->mlist[i]);
-	free(ms->o.pbuf);
-	free(ms->o.buf);
-	free(ms->c.li);
-	free(ms);
+	if (ms->o.pbuf) {
+		efree(ms->o.pbuf);
+	}
+	if (ms->o.buf) {
+		efree(ms->o.buf);
+	}
+	if (ms->c.li) {
+		efree(ms->c.li);
+	}
+	efree(ms);
 }
 
 protected struct magic_set *
@@ -473,7 +466,7 @@
 	struct magic_set *ms;
 	size_t i, len;
 
-	if ((ms = CAST(struct magic_set *, calloc((size_t)1,
+	if ((ms = CAST(struct magic_set *, ecalloc((size_t)1,
 	    sizeof(struct magic_set)))) == NULL)
 		return NULL;
 
@@ -485,7 +478,7 @@
 	ms->o.buf = ms->o.pbuf = NULL;
 	len = (ms->c.len = 10) * sizeof(*ms->c.li);
 
-	if ((ms->c.li = CAST(struct level_info *, malloc(len))) == NULL)
+	if ((ms->c.li = CAST(struct level_info *, emalloc(len))) == NULL)
 		goto free;
 
 	ms->event_flags = 0;
@@ -496,7 +489,7 @@
 	ms->line = 0;
 	return ms;
 free:
-	free(ms);
+	efree(ms);
 	return NULL;
 }
 
@@ -505,22 +498,26 @@
 {
 	if (map == NULL)
 		return;
-	if (map->p == NULL)
-		return;
-#ifdef QUICK
-	if (map->len)
-		(void)munmap(map->p, map->len);
-	else
-#endif
-		free(map->p);
-	free(map);
+	if (map->p != php_magic_database) {
+		if (map->p == NULL) {
+			int j;
+			for (j = 0; j < MAGIC_SETS; j++) {
+				if (map->magic[j]) {
+					efree(map->magic[j]);
+				}
+			}
+		} else {
+			efree(map->p);
+		}
+	}
+	efree(map);
 }
 
 private struct mlist *
 mlist_alloc(void)
 {
 	struct mlist *mlist;
-	if ((mlist = CAST(struct mlist *, calloc(1, sizeof(*mlist)))) == NULL) {
+	if ((mlist = CAST(struct mlist *, ecalloc(1, sizeof(*mlist)))) == NULL) {
 		return NULL;
 	}
 	mlist->next = mlist->prev = mlist;
@@ -539,10 +536,10 @@
 		struct mlist *next = ml->next;
 		if (ml->map)
 			apprentice_unmap(ml->map);
-		free(ml);
+		efree(ml);
 		ml = next;
 	}
-	free(ml);
+	efree(ml);
 }
 
 /* const char *fn: list of magic files and directories */
@@ -555,12 +552,28 @@
 
 	file_reset(ms);
 
+/* XXX disabling default magic loading so the compiled in data is used */
+#if 0
 	if ((fn = magic_getpath(fn, action)) == NULL)
 		return -1;
+#endif
 
 	init_file_tables();
 
-	if ((mfn = strdup(fn)) == NULL) {
+	if (fn == NULL)
+		fn = getenv("MAGIC");
+	if (fn == NULL) {
+		for (i = 0; i < MAGIC_SETS; i++) {
+			mlist_free(ms->mlist[i]);
+			if ((ms->mlist[i] = mlist_alloc()) == NULL) {
+				file_oomem(ms, sizeof(*ms->mlist[i]));
+				return -1;
+			}
+		}
+		return apprentice_1(ms, fn, action);
+	}
+
+	if ((mfn = estrdup(fn)) == NULL) {
 		file_oomem(ms, strlen(fn));
 		return -1;
 	}
@@ -575,7 +588,7 @@
 					mlist_free(ms->mlist[i]);
 				while (i != 0);
 			}
-			free(mfn);
+			efree(mfn);
 			return -1;
 		}
 	}
@@ -592,7 +605,7 @@
 		fn = p;
 	}
 
-	free(mfn);
+	efree(mfn);
 
 	if (errs == -1) {
 		for (i = 0; i < MAGIC_SETS; i++) {
@@ -918,7 +931,7 @@
 
 		mset[i].max += ALLOC_INCR;
 		if ((mp = CAST(struct magic_entry *,
-		    realloc(mset[i].me, sizeof(*mp) * mset[i].max))) ==
+		    erealloc(mset[i].me, sizeof(*mp) * mset[i].max))) ==
 		    NULL) {
 			file_oomem(ms, sizeof(*mp) * mset[i].max);
 			return -1;
@@ -939,13 +952,20 @@
 load_1(struct magic_set *ms, int action, const char *fn, int *errs,
    struct magic_entry_set *mset)
 {
-	size_t lineno = 0, llen = 0;
+	char buffer[BUFSIZ + 1];
 	char *line = NULL;
-	ssize_t len;
+	size_t len;
+	size_t lineno = 0;
 	struct magic_entry me;
 
-	FILE *f = fopen(ms->file = fn, "r");
-	if (f == NULL) {
+	php_stream *stream;
+
+	TSRMLS_FETCH();
+
+	ms->file = fn;
+	stream = php_stream_open_wrapper((char *)fn, "rb", REPORT_ERRORS, NULL);
+
+	if (stream == NULL) {
 		if (errno != ENOENT)
 			file_error(ms, errno, "cannot read magic file `%s'",
 				   fn);
@@ -955,8 +975,7 @@
 
 	memset(&me, 0, sizeof(me));
 	/* read and parse this file */
-	for (ms->line = 1; (len = getline(&line, &llen, f)) != -1;
-	    ms->line++) {
+	for (ms->line = 1; (line = php_stream_get_line(stream, buffer , BUFSIZ, &len)) != NULL; ms->line++) {
 		if (len == 0) /* null line, garbage, etc */
 			continue;
 		if (line[len - 1] == '\n') {
@@ -1014,8 +1033,7 @@
 	}
 	if (me.mp)
 		(void)addentry(ms, &me, mset);
-	free(line);
-	(void)fclose(f);
+	php_stream_close(stream);
 }
 
 /*
@@ -1094,7 +1112,7 @@
 		mentrycount += me[i].cont_count;
 
 	slen = sizeof(**ma) * mentrycount;
-	if ((*ma = CAST(struct magic *, malloc(slen))) == NULL) {
+	if ((*ma = CAST(struct magic *, emalloc(slen))) == NULL) {
 		file_oomem(ms, slen);
 		return -1;
 	}
@@ -1116,8 +1134,8 @@
 	if (me == NULL)
 		return;
 	for (i = 0; i < nme; i++)
-		free(me[i].mp);
-	free(me);
+		efree(me[i].mp);
+	efree(me);
 }
 
 private struct magic_map *
@@ -1126,18 +1144,20 @@
 	int errs = 0;
 	uint32_t i, j;
 	size_t files = 0, maxfiles = 0;
-	char **filearr = NULL, *mfn;
+	char **filearr = NULL;
 	struct stat st;
 	struct magic_map *map;
 	struct magic_entry_set mset[MAGIC_SETS];
-	DIR *dir;
-	struct dirent *d;
+	php_stream *dir;
+	php_stream_dirent d;
+ 
+	TSRMLS_FETCH();
 
 	memset(mset, 0, sizeof(mset));
 	ms->flags |= MAGIC_CHECK;	/* Enable checks for parsed files */
 
 
-	if ((map = CAST(struct magic_map *, calloc(1, sizeof(*map)))) == NULL)
+	if ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)
 	{
 		file_oomem(ms, sizeof(*map));
 		return NULL;
@@ -1148,22 +1168,26 @@
 		(void)fprintf(stderr, "%s\n", usg_hdr);
 
 	/* load directory or file */
-	if (stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {
-		dir = opendir(fn);
+	/* FIXME: Read file names and sort them to prevent
+	   non-determinism. See Debian bug #488562. */
+	if (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {
+		int mflen;
+		char mfn[MAXPATHLEN];
+
+		dir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);
 		if (!dir) {
 			errs++;
 			goto out;
 		}
-		while ((d = readdir(dir)) != NULL) {
-			if (asprintf(&mfn, "%s/%s", fn, d->d_name) < 0) {
+		while (php_stream_readdir(dir, &d)) {
+			if ((mflen = snprintf(mfn, sizeof(mfn), "%s/%s", fn, d.d_name)) < 0) {
 				file_oomem(ms,
-				    strlen(fn) + strlen(d->d_name) + 2);
+				strlen(fn) + strlen(d.d_name) + 2);
 				errs++;
-				closedir(dir);
+				php_stream_closedir(dir);
 				goto out;
 			}
 			if (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {
-				free(mfn);
 				continue;
 			}
 			if (files >= maxfiles) {
@@ -1171,23 +1195,22 @@
 				maxfiles = (maxfiles + 1) * 2;
 				mlen = maxfiles * sizeof(*filearr);
 				if ((filearr = CAST(char **,
-				    realloc(filearr, mlen))) == NULL) {
+				    erealloc(filearr, mlen))) == NULL) {
 					file_oomem(ms, mlen);
-					free(mfn);
-					closedir(dir);
+					php_stream_closedir(dir);
 					errs++;
 					goto out;
 				}
 			}
-			filearr[files++] = mfn;
+			filearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);
 		}
-		closedir(dir);
+		php_stream_closedir(dir);
 		qsort(filearr, files, sizeof(*filearr), cmpstrp);
 		for (i = 0; i < files; i++) {
 			load_1(ms, action, filearr[i], &errs, mset);
-			free(filearr[i]);
+			efree(filearr[i]);
 		}
-		free(filearr);
+		efree(filearr);
 	} else
 		load_1(ms, action, fn, &errs, mset);
 	if (errs)
@@ -1226,9 +1249,9 @@
 	if (errs) {
 		for (j = 0; j < MAGIC_SETS; j++) {
 			if (map->magic[j])
-				free(map->magic[j]);
+				efree(map->magic[j]);
 		}
-		free(map);
+		efree(map);
 		return NULL;
 	}
 	return map;
@@ -1248,7 +1271,7 @@
 		 * the sign extension must have happened.
 		 */
 		case FILE_BYTE:
-			v = (char) v;
+			v = (signed char) v;
 			break;
 		case FILE_SHORT:
 		case FILE_BESHORT:
@@ -1516,7 +1539,7 @@
 		if (me->cont_count == me->max_count) {
 			struct magic *nm;
 			size_t cnt = me->max_count + ALLOC_CHUNK;
-			if ((nm = CAST(struct magic *, realloc(me->mp,
+			if ((nm = CAST(struct magic *, erealloc(me->mp,
 			    sizeof(*nm) * cnt))) == NULL) {
 				file_oomem(ms, sizeof(*nm) * cnt);
 				return -1;
@@ -1531,7 +1554,7 @@
 		static const size_t len = sizeof(*m) * ALLOC_CHUNK;
 		if (me->mp != NULL)
 			return 1;
-		if ((m = CAST(struct magic *, malloc(len))) == NULL) {
+		if ((m = CAST(struct magic *, emalloc(len))) == NULL) {
 			file_oomem(ms, len);
 			return -1;
 		}
@@ -1704,7 +1727,7 @@
 				m->type = get_standard_integer_type(l, &l);
 			else if (*l == 's' && !isalpha((unsigned char)l[1])) {
 				m->type = FILE_STRING;
-				++l;
+		++l;
 			}
 		}
 	}
@@ -1717,6 +1740,10 @@
 	if (m->type == FILE_INVALID) {
 		if (ms->flags & MAGIC_CHECK)
 			file_magwarn(ms, "type `%s' invalid", l);
+		/*if (me->mp) {
+			efree(me->mp);
+			me->mp = NULL;
+		}*/
 		return -1;
 	}
 
@@ -1725,7 +1752,7 @@
 
 	m->mask_op = 0;
 	if (*l == '~') {
-		if (!IS_STRING(m->type))
+		if (!IS_LIBMAGIC_STRING(m->type))
 			m->mask_op |= FILE_OPINVERSE;
 		else if (ms->flags & MAGIC_CHECK)
 			file_magwarn(ms, "'~' invalid for string types");
@@ -1734,7 +1761,7 @@
 	m->str_range = 0;
 	m->str_flags = m->type == FILE_PSTRING ? PSTRING_1_LE : 0;
 	if ((op = get_op(*l)) != -1) {
-		if (!IS_STRING(m->type)) {
+		if (!IS_LIBMAGIC_STRING(m->type)) {
 			uint64_t val;
 			++l;
 			m->mask_op |= op;
@@ -1925,11 +1952,6 @@
 		if (check_format(ms, m) == -1)
 			return -1;
 	}
-#ifndef COMPILE_ONLY
-	if (action == FILE_CHECK) {
-		file_mdump(m);
-	}
-#endif
 	m->mimetype[0] = '\0';		/* initialise MIME type to none */
 	return 0;
 }
@@ -2575,59 +2597,75 @@
 private struct magic_map *
 apprentice_map(struct magic_set *ms, const char *fn)
 {
-	int fd;
-	struct stat st;
 	uint32_t *ptr;
 	uint32_t version, entries, nentries;
 	int needsbyteswap;
 	char *dbname = NULL;
 	struct magic_map *map;
 	size_t i;
+	php_stream *stream = NULL;
+	php_stream_statbuf st;
 
-	fd = -1;
-	if ((map = CAST(struct magic_map *, calloc(1, sizeof(*map)))) == NULL) {
+
+	TSRMLS_FETCH();
+
+	if ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL) {
 		file_oomem(ms, sizeof(*map));
-		goto error;
+		return NULL;
+	}
+
+	if (fn == NULL) {
+		map->p = (void *)&php_magic_database;
+		goto internal_loaded;
 	}
 
+#ifdef PHP_WIN32
+	/* Don't bother on windows with php_stream_open_wrapper,
+	return to give apprentice_load() a chance. */
+	if (php_stream_stat_path_ex((char *)fn, 0, &st, NULL) == SUCCESS) {
+               if (st.sb.st_mode & S_IFDIR) {
+                       return NULL;
+               }
+       }
+#endif
+
 	dbname = mkdbname(ms, fn, 0);
 	if (dbname == NULL)
 		goto error;
 
-	if ((fd = open(dbname, O_RDONLY|O_BINARY)) == -1)
+		stream = php_stream_open_wrapper((char *)fn, "rb", REPORT_ERRORS, NULL);
+
+	if (!stream) {
 		goto error;
+	}
 
-	if (fstat(fd, &st) == -1) {
+	if (php_stream_stat(stream, &st) < 0) {
 		file_error(ms, errno, "cannot stat `%s'", dbname);
 		goto error;
 	}
-	if (st.st_size < 8) {
+
+	if (st.sb.st_size < 8) {
 		file_error(ms, 0, "file `%s' is too small", dbname);
 		goto error;
 	}
 
-	map->len = (size_t)st.st_size;
-#ifdef QUICK
-	if ((map->p = mmap(0, (size_t)st.st_size, PROT_READ|PROT_WRITE,
-	    MAP_PRIVATE|MAP_FILE, fd, (off_t)0)) == MAP_FAILED) {
-		file_error(ms, errno, "cannot map `%s'", dbname);
-		goto error;
-	}
-#else
-	if ((map->p = CAST(void *, malloc(map->len))) == NULL) {
+	map->len = (size_t)st.sb.st_size;
+	if ((map->p = CAST(void *, emalloc(map->len))) == NULL) {
 		file_oomem(ms, map->len);
 		goto error;
 	}
-	if (read(fd, map->p, map->len) != (ssize_t)map->len) {
+	if (php_stream_read(stream, map->p, (size_t)st.sb.st_size) != (size_t)st.sb.st_size) {
 		file_badread(ms);
 		goto error;
 	}
 	map->len = 0;
 #define RET	1
-#endif
-	(void)close(fd);
-	fd = -1;
-	ptr = CAST(uint32_t *, map->p);
+
+	php_stream_close(stream);
+	stream = NULL;
+
+internal_loaded:
+	ptr = (uint32_t *)(void *)map->p;
 	if (*ptr != MAGICNO) {
 		if (swap4(*ptr) != MAGICNO) {
 			file_error(ms, 0, "bad magic in `%s'", dbname);
@@ -2641,17 +2679,29 @@
 	else
 		version = ptr[1];
 	if (version != VERSIONNO) {
-		file_error(ms, 0, "File %s supports only version %d magic "
-		    "files. `%s' is version %d", VERSION,
+		file_error(ms, 0, "File %d.%d supports only version %d magic "
+		    "files. `%s' is version %d", FILE_VERSION_MAJOR, patchlevel,
 		    VERSIONNO, dbname, version);
 		goto error;
 	}
-	entries = (uint32_t)(st.st_size / sizeof(struct magic));
-	if ((off_t)(entries * sizeof(struct magic)) != st.st_size) {
-		file_error(ms, 0, "Size of `%s' %llu is not a multiple of %zu",
-		    dbname, (unsigned long long)st.st_size,
-		    sizeof(struct magic));
-		goto error;
+
+	/* php_magic_database is a const, performing writes will segfault. This is for big-endian
+	machines only, PPC and Sparc specifically. Consider static variable or MINIT in
+	future. */
+	if (needsbyteswap && fn == NULL) {
+		map->p = emalloc(sizeof(php_magic_database));
+		map->p = memcpy(map->p, php_magic_database, sizeof(php_magic_database));
+	}
+
+	if (NULL != fn) {
+		nentries = (uint32_t)(st.sb.st_size / sizeof(struct magic));
+		entries = (uint32_t)(st.sb.st_size / sizeof(struct magic));
+		if ((off_t)(entries * sizeof(struct magic)) != st.sb.st_size) {
+			file_error(ms, 0, "Size of `%s' %llu is not a multiple of %zu",
+				dbname, (unsigned long long)st.sb.st_size,
+				sizeof(struct magic));
+			goto error;
+		}
 	}
 	map->magic[0] = CAST(struct magic *, map->p) + 1;
 	nentries = 0;
@@ -2664,22 +2714,29 @@
 			map->magic[i + 1] = map->magic[i] + map->nmagic[i];
 		nentries += map->nmagic[i];
 	}
-	if (entries != nentries + 1) {
+	if (NULL != fn && entries != nentries + 1) {
 		file_error(ms, 0, "Inconsistent entries in `%s' %u != %u",
 		    dbname, entries, nentries + 1);
 		goto error;
 	}
+
 	if (needsbyteswap)
 		for (i = 0; i < MAGIC_SETS; i++)
 			byteswap(map->magic[i], map->nmagic[i]);
-	free(dbname);
+
+	if (dbname) {
+		efree(dbname);
+	}
 	return map;
 
 error:
-	if (fd != -1)
-		(void)close(fd);
+	if (stream) {
+		php_stream_close(stream);
+	}
 	apprentice_unmap(map);
-	free(dbname);
+	if (dbname) {
+		efree(dbname);
+	}
 	return NULL;
 }
 
@@ -2700,14 +2757,19 @@
 	char *dbname;
 	int rv = -1;
 	uint32_t i;
+	php_stream *stream;
+
+	TSRMLS_FETCH();
 
-	dbname = mkdbname(ms, fn, 1);
+	dbname = mkdbname(ms, fn, 0);
 
 	if (dbname == NULL) 
 		goto out;
 
-	if ((fd = open(dbname, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0644)) == -1) 
-	{
+	/* wb+ == O_WRONLY|O_CREAT|O_TRUNC|O_BINARY */
+	stream = php_stream_open_wrapper((char *)fn, "wb+", REPORT_ERRORS, NULL);
+
+	if (!stream) {
 		file_error(ms, errno, "cannot open `%s'", dbname);
 		goto out;
 	}
@@ -2717,31 +2779,33 @@
 		goto out;
 	}
 
-	if (write(fd, map->nmagic, nm) != (ssize_t)nm) {
+	if (php_stream_write(stream, (const char *)map->nmagic, nm) != (ssize_t)nm) {
 		file_error(ms, errno, "error writing `%s'", dbname);
 		goto out;
 	}
 
 	assert(nm + sizeof(ar) < m);
 
-	if (lseek(fd, (off_t)m, SEEK_SET) != (off_t)m) {
+	if (php_stream_seek(stream,(off_t)sizeof(struct magic), SEEK_SET) != sizeof(struct magic)) {
 		file_error(ms, errno, "error seeking `%s'", dbname);
 		goto out;
 	}
 
 	for (i = 0; i < MAGIC_SETS; i++) {
 		len = m * map->nmagic[i];
-		if (write(fd, map->magic[i], len) != (ssize_t)len) {
+		if (php_stream_write(stream, (const char *)map->magic[i], len) != (ssize_t)len) {
 			file_error(ms, errno, "error writing `%s'", dbname);
 			goto out;
 		}
 	}
 
-	if (fd != -1)
-		(void)close(fd);
+	if (stream) {
+		php_stream_close(stream);
+	}
+
 	rv = 0;
 out:
-	free(dbname);
+	efree(dbname);
 	return rv;
 }
 
@@ -2754,6 +2818,7 @@
 {
 	const char *p, *q;
 	char *buf;
+	TSRMLS_FETCH();
 
 	if (strip) {
 		if ((p = strrchr(fn, '/')) != NULL)
@@ -2775,16 +2840,18 @@
 	q++;
 	/* Compatibility with old code that looked in .mime */
 	if (ms->flags & MAGIC_MIME) {
-		if (asprintf(&buf, "%.*s.mime%s", (int)(q - fn), fn, ext) < 0)
-			return NULL;
-		if (access(buf, R_OK) != -1) {
+		spprintf(&buf, MAXPATHLEN, "%.*s.mime%s", (int)(q - fn), fn, ext);
+#ifdef PHP_WIN32
+		if (VCWD_ACCESS(buf, R_OK) == 0) {
+#else
+		if (VCWD_ACCESS(buf, R_OK) != -1) {
+#endif
 			ms->flags &= MAGIC_MIME_TYPE;
 			return buf;
 		}
-		free(buf);
+		efree(buf);
 	}
-	if (asprintf(&buf, "%.*s%s", (int)(q - fn), fn, ext) < 0)
-		return NULL;
+	spprintf(&buf, MAXPATHLEN, "%.*s%s", (int)(q - fn), fn, ext);
 
 	/* Compatibility with old code that looked in .mime */
 	if (strstr(p, ".mime") != NULL)
@@ -2874,7 +2941,7 @@
 	m->offset = swap4((uint32_t)m->offset);
 	m->in_offset = swap4((uint32_t)m->in_offset);
 	m->lineno = swap4((uint32_t)m->lineno);
-	if (IS_STRING(m->type)) {
+	if (IS_LIBMAGIC_STRING(m->type)) {
 		m->str_range = swap4(m->str_range);
 		m->str_flags = swap4(m->str_flags);
 	}
diff -u libmagic.orig/ascmagic.c libmagic/ascmagic.c
--- libmagic.orig/ascmagic.c	2016-01-25 11:17:38.161978563 +0800
+++ libmagic/ascmagic.c	2016-01-25 11:19:37.410347842 +0800
@@ -139,7 +139,7 @@
 		/* malloc size is a conservative overestimate; could be
 		   improved, or at least realloced after conversion. */
 		mlen = ulen * 6;
-		if ((utf8_buf = CAST(unsigned char *, malloc(mlen))) == NULL) {
+		if ((utf8_buf = CAST(unsigned char *, emalloc(mlen))) == NULL) {
 			file_oomem(ms, mlen);
 			goto done;
 		}
@@ -297,7 +297,8 @@
 	}
 	rv = 1;
 done:
-	free(utf8_buf);
+	if (utf8_buf)
+		efree(utf8_buf);
 
 	return rv;
 }
diff -u libmagic.orig/cdf.c libmagic/cdf.c
--- libmagic.orig/cdf.c	2016-01-25 11:17:38.140978563 +0800
+++ libmagic/cdf.c	2016-01-25 11:19:37.410347842 +0800
@@ -35,7 +35,7 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: cdf.c,v 1.53 2013/02/26 16:20:42 christos Exp $")
+FILE_RCSID("@(#)$File: cdf.c,v 1.55 2014/02/27 23:26:17 christos Exp $")
 #endif
 
 #include <assert.h>
@@ -43,7 +43,17 @@
 #include <err.h>
 #endif
 #include <stdlib.h>
+
+#ifdef PHP_WIN32
+#include "win32/unistd.h"
+#else
 #include <unistd.h>
+#endif
+
+#ifndef UINT32_MAX
+# define UINT32_MAX (0xffffffff)
+#endif
+
 #include <string.h>
 #include <time.h>
 #include <ctype.h>
@@ -267,13 +277,15 @@
 {
 	const char *b = (const char *)sst->sst_tab;
 	const char *e = ((const char *)p) + tail;
+	size_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?
+	    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);
 	(void)&line;
-	if (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)
+	if (e >= b && (size_t)(e - b) <= ss * sst->sst_len)
 		return 0;
 	DPRINTF(("%d: offset begin %p < end %p || %" SIZE_T_FORMAT "u"
 	    " > %" SIZE_T_FORMAT "u [%" SIZE_T_FORMAT "u %"
 	    SIZE_T_FORMAT "u]\n", line, b, e, (size_t)(e - b),
-	    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));
+	    ss * sst->sst_len, ss, sst->sst_len));
 	errno = EFTYPE;
 	return -1;
 }
@@ -296,7 +308,10 @@
 	if (info->i_fd == -1)
 		return -1;
 
-	if (pread(info->i_fd, buf, len, off) != (ssize_t)len)
+	if (FINFO_LSEEK_FUNC(info->i_fd, off, SEEK_SET) == (off_t)-1)
+		return -1;
+
+	if (FINFO_READ_FUNC(info->i_fd, buf, len) != (ssize_t)len)
 		return -1;
 
 	return (ssize_t)len;
@@ -352,10 +367,10 @@
 	size_t ss = CDF_SHORT_SEC_SIZE(h);
 	size_t pos = CDF_SHORT_SEC_POS(h, id);
 	assert(ss == len);
-	if (pos > CDF_SEC_SIZE(h) * sst->sst_len) {
+	if (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {
 		DPRINTF(("Out of bounds read %" SIZE_T_FORMAT "u > %"
 		    SIZE_T_FORMAT "u\n",
-		    pos, CDF_SEC_SIZE(h) * sst->sst_len));
+		    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));
 		return -1;
 	}
 	(void)memcpy(((char *)buf) + offs,
@@ -455,7 +470,8 @@
 cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)
 {
 	size_t i, j;
-	cdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);
+	cdf_secid_t maxsector = (cdf_secid_t)((sat->sat_len * size)
+	    / sizeof(maxsector));
 
 	DPRINTF(("Chain:"));
 	for (j = i = 0; sid >= 0; i++, j++) {
@@ -465,8 +481,8 @@
 			errno = EFTYPE;
 			return (size_t)-1;
 		}
-		if (sid > maxsector) {
-			DPRINTF(("Sector %d > %d\n", sid, maxsector));
+		if (sid >= maxsector) {
+			DPRINTF(("Sector %d >= %d\n", sid, maxsector));
 			errno = EFTYPE;
 			return (size_t)-1;
 		}
@@ -675,11 +691,13 @@
 
 int
 cdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,
-    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn)
+    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,
+    const cdf_directory_t **root)
 {
 	size_t i;
 	const cdf_directory_t *d;
 
+	*root = NULL;
 	for (i = 0; i < dir->dir_len; i++)
 		if (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)
 			break;
@@ -688,6 +706,7 @@
 	if (i == dir->dir_len)
 		goto out;
 	d = &dir->dir_tab[i];
+	*root = d;
 
 	/* If the it is not there, just fake it; some docs don't have it */
 	if (d->d_stream_first_sector < 0)
@@ -796,11 +815,15 @@
 	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
 		goto out;
 	for (i = 0; i < sh.sh_properties; i++) {
-		size_t ofs = CDF_GETUINT32(p, (i << 1) + 1);
+		size_t ofs, tail = (i << 1) + 1;
+		if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),
+		    __LINE__) == -1)
+			goto out;
+		ofs = CDF_GETUINT32(p, tail);
 		q = (const uint8_t *)(const void *)
 		    ((const char *)(const void *)p + ofs
 		    - 2 * sizeof(uint32_t));
-		if (q > e) {
+		if (q < p || q > e) {
 			DPRINTF(("Ran of the end %p > %p\n", q, e));
 			goto out;
 		}
@@ -810,6 +833,10 @@
 		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
 		if (inp[i].pi_type & CDF_VECTOR) {
 			nelements = CDF_GETUINT32(q, 1);
+			if (nelements == 0) {
+				DPRINTF(("CDF_VECTOR with nelements == 0\n"));
+				goto out;
+			}
 			o = 2;
 		} else {
 			nelements = 1;
@@ -884,7 +911,9 @@
 			}
 			DPRINTF(("nelements = %" SIZE_T_FORMAT "u\n",
 			    nelements));
-			for (j = 0; j < nelements; j++, i++) {
+			for (j = 0; j < nelements && i < sh.sh_properties; 
+			    j++, i++) 
+			{
 				uint32_t l = CDF_GETUINT32(q, o);
 				inp[i].pi_str.s_len = l;
 				inp[i].pi_str.s_buf = (const char *)
@@ -929,7 +958,7 @@
 cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,
     cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)
 {
-	size_t i, maxcount;
+	size_t maxcount;
 	const cdf_summary_info_header_t *si =
 	    CAST(const cdf_summary_info_header_t *, sst->sst_tab);
 	const cdf_section_declaration_t *sd =
@@ -944,21 +973,13 @@
 	ssi->si_os = CDF_TOLE2(si->si_os);
 	ssi->si_class = si->si_class;
 	cdf_swap_class(&ssi->si_class);
-	ssi->si_count = CDF_TOLE2(si->si_count);
+	ssi->si_count = CDF_TOLE4(si->si_count);
 	*count = 0;
 	maxcount = 0;
 	*info = NULL;
-	for (i = 0; i < CDF_TOLE4(si->si_count); i++) {
-		if (i >= CDF_LOOP_LIMIT) {
-			DPRINTF(("Unpack summary info loop limit"));
-			errno = EFTYPE;
-			return -1;
-		}
-		if (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),
-		    info, count, &maxcount) == -1) {
+	if (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,
+		count, &maxcount) == -1) 
 			return -1;
-		}
-	}
 	return 0;
 }
 
@@ -1132,7 +1153,7 @@
 	cdf_directory_t *d;
 	char name[__arraycount(d->d_name)];
 	cdf_stream_t scn;
-	struct timespec ts;
+	struct timeval ts;
 
 	static const char *types[] = { "empty", "user storage",
 	    "user stream", "lockbytes", "property", "root storage" };
@@ -1185,7 +1206,7 @@
 cdf_dump_property_info(const cdf_property_info_t *info, size_t count)
 {
 	cdf_timestamp_t tp;
-	struct timespec ts;
+	struct timeval ts;
 	char buf[64];
 	size_t i, j;
 
@@ -1229,7 +1250,11 @@
 			break;
 		case CDF_FILETIME:
 			tp = info[i].pi_tp;
+#if defined(PHP_WIN32) && _MSC_VER <= 1500
+		if (tp < 1000000000000000i64) {
+#else
 			if (tp < 1000000000000000LL) {
+#endif
 				cdf_print_elapsed_time(buf, sizeof(buf), tp);
 				(void)fprintf(stderr, "timestamp %s\n", buf);
 			} else {
diff -u libmagic.orig/cdf.h libmagic/cdf.h
--- libmagic.orig/cdf.h	2016-01-25 11:17:38.160978563 +0800
+++ libmagic/cdf.h	2016-01-25 11:19:37.410347842 +0800
@@ -35,10 +35,12 @@
 #ifndef _H_CDF_
 #define _H_CDF_
 
-#ifdef WIN32
+#ifdef PHP_WIN32
 #include <winsock2.h>
 #define timespec timeval
 #define tv_nsec tv_usec
+#define asctime_r php_asctime_r
+#define ctime_r php_ctime_r
 #endif
 #ifdef __DJGPP__
 #define timespec timeval
@@ -57,7 +59,11 @@
 
 typedef struct {
 	uint64_t	h_magic;
-#define CDF_MAGIC	0xE11AB1A1E011CFD0LL
+#if defined(PHP_WIN32) && _MSC_VER <= 1500
+# define CDF_MAGIC	0xE11AB1A1E011CFD0i64
+#else
+# define CDF_MAGIC	0xE11AB1A1E011CFD0LL
+#endif
 	uint64_t	h_uuid[2];
 	uint16_t	h_revision;
 	uint16_t	h_version;
@@ -267,9 +273,9 @@
 	size_t i_len;
 } cdf_info_t;
 
-struct timespec;
-int cdf_timestamp_to_timespec(struct timespec *, cdf_timestamp_t);
-int cdf_timespec_to_timestamp(cdf_timestamp_t *, const struct timespec *);
+struct timeval;
+int cdf_timestamp_to_timespec(struct timeval *, cdf_timestamp_t);
+int cdf_timespec_to_timestamp(cdf_timestamp_t *, const struct timeval *);
 int cdf_read_header(const cdf_info_t *, cdf_header_t *);
 void cdf_swap_header(cdf_header_t *);
 void cdf_unpack_header(cdf_header_t *, char *);
@@ -294,7 +300,8 @@
 int cdf_read_ssat(const cdf_info_t *, const cdf_header_t *, const cdf_sat_t *,
     cdf_sat_t *);
 int cdf_read_short_stream(const cdf_info_t *, const cdf_header_t *,
-    const cdf_sat_t *, const cdf_dir_t *, cdf_stream_t *);
+    const cdf_sat_t *, const cdf_dir_t *, cdf_stream_t *,
+    const cdf_directory_t **);
 int cdf_read_property_info(const cdf_stream_t *, const cdf_header_t *, uint32_t,
     cdf_property_info_t **, size_t *, size_t *);
 int cdf_read_summary_info(const cdf_info_t *, const cdf_header_t *,
diff -u libmagic.orig/cdf_time.c libmagic/cdf_time.c
--- libmagic.orig/cdf_time.c	2016-01-25 11:17:38.160978563 +0800
+++ libmagic/cdf_time.c	2016-01-25 11:19:37.410347842 +0800
@@ -96,7 +96,7 @@
 }
 
 int
-cdf_timestamp_to_timespec(struct timespec *ts, cdf_timestamp_t t)
+cdf_timestamp_to_timespec(struct timeval *ts, cdf_timestamp_t t)
 {
 	struct tm tm;
 #ifdef HAVE_STRUCT_TM_TM_ZONE
@@ -104,8 +104,9 @@
 #endif
 	int rdays;
 
-	/* Unit is 100's of nanoseconds */
-	ts->tv_nsec = (t % CDF_TIME_PREC) * 100;
+	/* XXX 5.14 at least introdced 100 ns intervals, this is to do */
+	/* Time interval, in microseconds */
+	ts->tv_usec = (t % CDF_TIME_PREC) * CDF_TIME_PREC;
 
 	t /= CDF_TIME_PREC;
 	tm.tm_sec = (int)(t % 60);
@@ -117,7 +118,7 @@
 	tm.tm_hour = (int)(t % 24);
 	t /= 24;
 
-	// XXX: Approx
+	/* XXX: Approx */
 	tm.tm_year = (int)(CDF_BASE_YEAR + (t / 365));
 
 	rdays = cdf_getdays(tm.tm_year);
@@ -144,7 +145,7 @@
 
 int
 /*ARGSUSED*/
-cdf_timespec_to_timestamp(cdf_timestamp_t *t, const struct timespec *ts)
+cdf_timespec_to_timestamp(cdf_timestamp_t *t, const struct timeval *ts)
 {
 #ifndef __lint__
 	(void)&t;
@@ -156,7 +157,7 @@
 		errno = EINVAL;
 		return -1;
 	}
-	*t = (ts->ts_nsec / 100) * CDF_TIME_PREC;
+	*t = (ts->ts_usec / CDF_TIME_PREC) * CDF_TIME_PREC;
 	*t = tm.tm_sec;
 	*t += tm.tm_min * 60;
 	*t += tm.tm_hour * 60 * 60;
@@ -180,7 +181,7 @@
 int
 main(int argc, char *argv[])
 {
-	struct timespec ts;
+	struct timeval ts;
 	char buf[25];
 	static const cdf_timestamp_t tst = 0x01A5E403C2D59C00ULL;
 	static const char *ref = "Sat Apr 23 01:30:00 1977";
diff -u libmagic.orig/compress.c libmagic/compress.c
--- libmagic.orig/compress.c	2016-01-25 11:17:38.149978563 +0800
+++ libmagic/compress.c	2016-01-25 11:19:37.410347842 +0800
@@ -32,6 +32,7 @@
  *	uncompress(method, old, n, newch) - uncompress old into new, 
  *					    using method, return sizeof new
  */
+#include "config.h"
 #include "file.h"
 
 #ifndef lint
@@ -45,7 +46,8 @@
 #endif
 #include <string.h>
 #include <errno.h>
-#ifndef __MINGW32__
+#include <sys/types.h>
+#ifndef PHP_WIN32
 #include <sys/ioctl.h>
 #endif
 #ifdef HAVE_SYS_WAIT_H
@@ -59,6 +61,9 @@
 #include <zlib.h>
 #endif
 
+#undef FIONREAD
+
+
 private const struct {
 	const char magic[8];
 	size_t maglen;
@@ -86,8 +91,7 @@
 #define NODATA ((size_t)~0)
 
 private ssize_t swrite(int, const void *, size_t);
-#if HAVE_FORK
-private size_t ncompr = sizeof(compr) / sizeof(compr[0]);
+#ifdef PHP_FILEINFO_UNCOMPRESS
 private size_t uncompressbuf(struct magic_set *, int, size_t,
     const unsigned char *, unsigned char **, size_t);
 #ifdef BUILTIN_DECOMPRESS
@@ -103,10 +107,13 @@
 	size_t i, nsz;
 	int rv = 0;
 	int mime = ms->flags & MAGIC_MIME;
+	size_t ncompr;
 
 	if ((ms->flags & MAGIC_COMPRESS) == 0)
 		return 0;
 
+	ncompr = sizeof(compr) / sizeof(compr[0]);
+
 	for (i = 0; i < ncompr; i++) {
 		if (nbytes < compr[i].maglen)
 			continue;
@@ -133,7 +140,8 @@
 		}
 	}
 error:
-	free(newbuf);
+	if (newbuf)
+		efree(newbuf);
 	ms->flags |= MAGIC_COMPRESS;
 	return rv;
 }
@@ -167,7 +175,7 @@
  * `safe' read for sockets and pipes.
  */
 protected ssize_t
-sread(int fd, void *buf, size_t n, int canbepipe __attribute__((__unused__)))
+sread(int fd, void *buf, size_t n, int canbepipe)
 {
 	ssize_t rv;
 #ifdef FIONREAD
@@ -215,7 +223,7 @@
 
 nocheck:
 	do
-		switch ((rv = read(fd, buf, n))) {
+		switch ((rv = FINFO_READ_FUNC(fd, buf, n))) {
 		case -1:
 			if (errno == EINTR)
 				continue;
@@ -292,13 +300,14 @@
 		return -1;
 	}
 	(void)close(tfd);
-	if (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) {
+	if (FINFO_LSEEK_FUNC(fd, (off_t)0, SEEK_SET) == (off_t)-1) {
 		file_badseek(ms);
 		return -1;
 	}
 	return fd;
 }
-#if HAVE_FORK
+
+#ifdef PHP_FILEINFO_UNCOMPRESS
 #ifdef BUILTIN_DECOMPRESS
 
 #define FHCRC		(1 << 1)
@@ -335,7 +344,7 @@
 
 	if (data_start >= n)
 		return 0;
-	if ((*newch = CAST(unsigned char *, malloc(HOWMANY + 1))) == NULL) {
+	if ((*newch = CAST(unsigned char *, emalloc(HOWMANY + 1))) == NULL) {
 		return 0;
 	}
 	
@@ -396,19 +405,16 @@
 	case 0:	/* child */
 		(void) close(0);
 		if (fd != -1) {
-		    if (dup(fd) == -1)
-			_exit(1);
-		    (void) lseek(0, (off_t)0, SEEK_SET);
+		    (void) dup(fd);
+		    (void) FINFO_LSEEK_FUNC(0, (off_t)0, SEEK_SET);
 		} else {
-		    if (dup(fdin[0]) == -1)
-			_exit(1);
+		    (void) dup(fdin[0]);
 		    (void) close(fdin[0]);
 		    (void) close(fdin[1]);
 		}
 
 		(void) close(1);
-		if (dup(fdout[1]) == -1)
-			_exit(1);
+		(void) dup(fdout[1]);
 		(void) close(fdout[0]);
 		(void) close(fdout[1]);
 #ifndef DEBUG
@@ -465,20 +471,14 @@
 			fdin[1] = -1;
 		}
 
-		if ((*newch = (unsigned char *) malloc(HOWMANY + 1)) == NULL) {
-#ifdef DEBUG
-			(void)fprintf(stderr, "Malloc failed (%s)\n",
-			    strerror(errno));
-#endif
-			n = 0;
-			goto err;
-		}
+		*newch = (unsigned char *) emalloc(HOWMANY + 1);
+
 		if ((r = sread(fdout[0], *newch, HOWMANY, 0)) <= 0) {
 #ifdef DEBUG
 			(void)fprintf(stderr, "Read failed (%s)\n",
 			    strerror(errno));
 #endif
-			free(*newch);
+			efree(*newch);
 			n = 0;
 			*newch = NULL;
 			goto err;
@@ -502,4 +502,4 @@
 		return n;
 	}
 }
-#endif
+#endif /* if PHP_FILEINFO_UNCOMPRESS */
diff -u libmagic.orig/file.h libmagic/file.h
--- libmagic.orig/file.h	2016-01-25 11:17:38.140978563 +0800
+++ libmagic/file.h	2016-01-25 11:19:37.411347842 +0800
@@ -33,11 +33,9 @@
 #ifndef __file_h__
 #define __file_h__
 
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
+#include "config.h"
 
-#ifdef WIN32
+#ifdef PHP_WIN32
   #ifdef _WIN64
     #define SIZE_T_FORMAT "I64"
   #else
@@ -61,10 +59,20 @@
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
-#include <regex.h>
-#include <time.h>
+#ifdef PHP_WIN32
+#include "win32/php_stdint.h"
+#endif
+
+#include "php.h"
+#include "ext/standard/php_string.h"
+#include "ext/pcre/php_pcre.h"
+
 #include <sys/types.h>
+#ifdef PHP_WIN32
+#include "win32/param.h"
+#else
 #include <sys/param.h>
+#endif
 /* Do this here and now, because struct stat gets re-defined on solaris */
 #include <sys/stat.h>
 #include <stdarg.h>
@@ -75,7 +83,7 @@
 #define MAGIC "/etc/magic"
 #endif
 
-#if defined(__EMX__) || defined (WIN32)
+#if defined(__EMX__) || defined(PHP_WIN32)
 #define PATHSEP	';'
 #else
 #define PATHSEP	':'
@@ -109,12 +117,6 @@
 #endif
 #endif
 
-#ifndef __GNUC__
-#ifndef __attribute__
-#define __attribute__(a)
-#endif
-#endif
-
 #ifndef MIN
 #define	MIN(a,b)	(((a) < (b)) ? (a) : (b))
 #endif
@@ -225,7 +227,7 @@
 #define				FILE_CLEAR	47
 #define				FILE_NAMES_SIZE	48 /* size of array to contain all names */
 
-#define IS_STRING(t) \
+#define IS_LIBMAGIC_STRING(t) \
 	((t) == FILE_STRING || \
 	 (t) == FILE_PSTRING || \
 	 (t) == FILE_BESTRING16 || \
@@ -411,22 +413,16 @@
 protected const char *file_fmttime(uint64_t, int, char *);
 protected struct magic_set *file_ms_alloc(int);
 protected void file_ms_free(struct magic_set *);
-protected int file_buffer(struct magic_set *, int, const char *, const void *,
+protected int file_buffer(struct magic_set *, php_stream *, const char *, const void *,
     size_t);
-protected int file_fsmagic(struct magic_set *, const char *, struct stat *);
+protected int file_fsmagic(struct magic_set *, const char *, struct stat *, php_stream *);
 protected int file_pipe2file(struct magic_set *, int, const void *, size_t);
-protected int file_vprintf(struct magic_set *, const char *, va_list)
-    __attribute__((__format__(__printf__, 2, 0)));
-protected size_t file_printedlen(const struct magic_set *);
 protected int file_replace(struct magic_set *, const char *, const char *);
-protected int file_printf(struct magic_set *, const char *, ...)
-    __attribute__((__format__(__printf__, 2, 3)));
+protected int file_printf(struct magic_set *, const char *, ...);
 protected int file_reset(struct magic_set *);
-protected int file_tryelf(struct magic_set *, int, const unsigned char *,
-    size_t);
 protected int file_trycdf(struct magic_set *, int, const unsigned char *,
     size_t);
-#if HAVE_FORK
+#ifdef PHP_FILEINFO_UNCOMPRESS
 protected int file_zmagic(struct magic_set *, int, const char *,
     const unsigned char *, size_t);
 #endif
@@ -444,16 +440,13 @@
 protected int file_magicfind(struct magic_set *, const char *, struct mlist *);
 protected uint64_t file_signextend(struct magic_set *, struct magic *,
     uint64_t);
+protected void file_delmagic(struct magic *, int type, size_t entries);
 protected void file_badread(struct magic_set *);
 protected void file_badseek(struct magic_set *);
 protected void file_oomem(struct magic_set *, size_t);
-protected void file_error(struct magic_set *, int, const char *, ...)
-    __attribute__((__format__(__printf__, 3, 4)));
-protected void file_magerror(struct magic_set *, const char *, ...)
-    __attribute__((__format__(__printf__, 2, 3)));
-protected void file_magwarn(struct magic_set *, const char *, ...)
-    __attribute__((__format__(__printf__, 2, 3)));
-protected void file_mdump(struct magic *);
+protected void file_error(struct magic_set *, int, const char *, ...);
+protected void file_magerror(struct magic_set *, const char *, ...);
+protected void file_magwarn(struct magic_set *, const char *, ...);
 protected void file_showstr(FILE *, const char *, size_t);
 protected size_t file_mbswidth(const char *);
 protected const char *file_getbuffer(struct magic_set *);
@@ -463,16 +456,14 @@
     size_t *);
 protected size_t file_pstring_length_size(const struct magic *);
 protected size_t file_pstring_get_length(const struct magic *, const char *);
+protected size_t file_printedlen(const struct magic_set *ms);
 #ifdef __EMX__
 protected int file_os2_apptype(struct magic_set *, const char *, const void *,
     size_t);
 #endif /* __EMX__ */
 
-
-#ifndef COMPILE_ONLY
 extern const char *file_names[];
 extern const size_t file_nnames;
-#endif
 
 #ifndef HAVE_STRERROR
 extern int sys_nerr;
@@ -485,20 +476,10 @@
 #define strtoul(a, b, c)	strtol(a, b, c)
 #endif
 
-#ifndef HAVE_PREAD
-ssize_t pread(int, void *, size_t, off_t);
-#endif
-#ifndef HAVE_VASPRINTF
-int vasprintf(char **, const char *, va_list);
-#endif
-#ifndef HAVE_ASPRINTF
-int asprintf(char **, const char *, ...);
-#endif
-
-#ifndef HAVE_STRLCPY
+#ifndef strlcpy
 size_t strlcpy(char *, const char *, size_t);
 #endif
-#ifndef HAVE_STRLCAT
+#ifndef strlcat
 size_t strlcat(char *, const char *, size_t);
 #endif
 #ifndef HAVE_STRCASESTR
@@ -537,4 +518,12 @@
 #define FILE_RCSID(id)
 #endif
 
+#ifdef PHP_WIN32
+#define FINFO_LSEEK_FUNC _lseek
+#define FINFO_READ_FUNC _read
+#else
+#define FINFO_LSEEK_FUNC lseek
+#define FINFO_READ_FUNC read
+#endif
+
 #endif /* __file_h__ */
diff -u libmagic.orig/fsmagic.c libmagic/fsmagic.c
--- libmagic.orig/fsmagic.c	2016-01-25 11:17:38.139978563 +0800
+++ libmagic/fsmagic.c	2016-01-25 11:19:37.411347842 +0800
@@ -59,27 +59,21 @@
 # define minor(dev)  ((dev) & 0xff)
 #endif
 #undef HAVE_MAJOR
-#ifdef	S_IFLNK
-private int
-bad_link(struct magic_set *ms, int err, char *buf)
-{
-	int mime = ms->flags & MAGIC_MIME;
-	if ((mime & MAGIC_MIME_TYPE) &&
-	    file_printf(ms, "inode/symlink")
-	    == -1)
-		return -1;
-	else if (!mime) {
-		if (ms->flags & MAGIC_ERROR) {
-			file_error(ms, err,
-				   "broken symbolic link to `%s'", buf);
-			return -1;
-		} 
-		if (file_printf(ms, "broken symbolic link to `%s'", buf) == -1)
-			return -1;
-	}
-	return 1;
-}
+
+#ifdef PHP_WIN32
+
+# undef S_IFIFO
 #endif
+
+
+#ifndef S_ISDIR
+#define S_ISDIR(mode) ((mode) & _S_IFDIR)
+#endif
+
+#ifndef S_ISREG
+#define S_ISREG(mode) ((mode) & _S_IFREG)
+#endif
+
 private int
 handle_mime(struct magic_set *ms, int mime, const char *str)
 {
@@ -96,42 +90,39 @@
 }
 
 protected int
-file_fsmagic(struct magic_set *ms, const char *fn, struct stat *sb)
+file_fsmagic(struct magic_set *ms, const char *fn, struct stat *sb, php_stream *stream)
 {
 	int ret, did = 0;
 	int mime = ms->flags & MAGIC_MIME;
-#ifdef	S_IFLNK
-	char buf[BUFSIZ+4];
-	ssize_t nch;
-	struct stat tstatbuf;
-#endif
+	TSRMLS_FETCH();
 
 	if (ms->flags & MAGIC_APPLE)
 		return 0;
-	if (fn == NULL)
+
+	if (fn == NULL && !stream) {
 		return 0;
+	}
 
 #define COMMA	(did++ ? ", " : "")
-	/*
-	 * Fstat is cheaper but fails for files you don't have read perms on.
-	 * On 4.2BSD and similar systems, use lstat() to identify symlinks.
-	 */
-#ifdef	S_IFLNK
-	if ((ms->flags & MAGIC_SYMLINK) == 0)
-		ret = lstat(fn, sb);
-	else
-#endif
-	ret = stat(fn, sb);	/* don't merge into if; see "ret =" above */
-
-	if (ret) {
-		if (ms->flags & MAGIC_ERROR) {
-			file_error(ms, errno, "cannot stat `%s'", fn);
-			return -1;
+
+	if (stream) {
+		php_stream_statbuf ssb;
+		if (php_stream_stat(stream, &ssb) < 0) {
+			if (ms->flags & MAGIC_ERROR) {
+				file_error(ms, errno, "cannot stat `%s'", fn);
+				return -1;
+			}
+			return 0;
+		}
+		memcpy(sb, &ssb.sb, sizeof(struct stat));
+	} else {
+		if (php_sys_stat(fn, sb) != 0) {
+			if (ms->flags & MAGIC_ERROR) {
+				file_error(ms, errno, "cannot stat `%s'", fn);
+				return -1;
+			}
+			return 0;
 		}
-		if (file_printf(ms, "cannot open `%s' (%s)",
-		    fn, strerror(errno)) == -1)
-			return -1;
-		return 0;
 	}
 
 	ret = 1;
@@ -154,30 +145,24 @@
 	}
 	
 	switch (sb->st_mode & S_IFMT) {
-	case S_IFDIR:
-		if (mime) {
-			if (handle_mime(ms, mime, "directory") == -1)
-				return -1;
-		} else if (file_printf(ms, "%sdirectory", COMMA) == -1)
-			return -1;
-		break;
-#ifdef S_IFCHR
-	case S_IFCHR:
-		/* 
-		 * If -s has been specified, treat character special files
-		 * like ordinary files.  Otherwise, just report that they
-		 * are block special files and go on to the next file.
-		 */
-		if ((ms->flags & MAGIC_DEVICES) != 0) {
-			ret = 0;
-			break;
-		}
-		if (mime) {
-			if (handle_mime(ms, mime, "chardevice") == -1)
-				return -1;
-		} else {
-#ifdef HAVE_STAT_ST_RDEV
-# ifdef dv_unit
+#ifndef PHP_WIN32
+# ifdef S_IFCHR
+		case S_IFCHR:
+			/* 
+			 * If -s has been specified, treat character special files
+			 * like ordinary files.  Otherwise, just report that they
+			 * are block special files and go on to the next file.
+			 */
+			if ((ms->flags & MAGIC_DEVICES) != 0) {
+				ret = 0;
+				break;
+			}
+			if (mime) {
+				if (handle_mime(ms, mime, "chardevice") == -1)
+					return -1;
+			} else {
+#  ifdef HAVE_STAT_ST_RDEV
+#   ifdef dv_unit
 			if (file_printf(ms, "%scharacter special (%d/%d/%d)",
 			    COMMA, major(sb->st_rdev), dv_unit(sb->st_rdev),
 					dv_subunit(sb->st_rdev)) == -1)
@@ -192,44 +177,11 @@
 			if (file_printf(ms, "%scharacter special", COMMA) == -1)
 				return -1;
 #endif
-		}
-		break;
-#endif
-#ifdef S_IFBLK
-	case S_IFBLK:
-		/* 
-		 * If -s has been specified, treat block special files
-		 * like ordinary files.  Otherwise, just report that they
-		 * are block special files and go on to the next file.
-		 */
-		if ((ms->flags & MAGIC_DEVICES) != 0) {
-			ret = 0;
-			break;
-		}
-		if (mime) {
-			if (handle_mime(ms, mime, "blockdevice") == -1)
-				return -1;
-		} else {
-#ifdef HAVE_STAT_ST_RDEV
-# ifdef dv_unit
-			if (file_printf(ms, "%sblock special (%d/%d/%d)",
-			    COMMA, major(sb->st_rdev), dv_unit(sb->st_rdev),
-			    dv_subunit(sb->st_rdev)) == -1)
-				return -1;
-# else
-			if (file_printf(ms, "%sblock special (%ld/%ld)",
-			    COMMA, (long)major(sb->st_rdev),
-			    (long)minor(sb->st_rdev)) == -1)
-				return -1;
+	}
+			return 1;
 # endif
-#else
-			if (file_printf(ms, "%sblock special", COMMA) == -1)
-				return -1;
-#endif
-		}
-		break;
 #endif
-	/* TODO add code to handle V7 MUX and Blit MUX files */
+
 #ifdef	S_IFIFO
 	case S_IFIFO:
 		if((ms->flags & MAGIC_DEVICES) != 0)
@@ -252,79 +204,14 @@
 #endif
 #ifdef	S_IFLNK
 	case S_IFLNK:
-		if ((nch = readlink(fn, buf, BUFSIZ-1)) <= 0) {
+		/* stat is used, if it made here then the link is broken */
 			if (ms->flags & MAGIC_ERROR) {
-			    file_error(ms, errno, "unreadable symlink `%s'",
-				fn);
+			    file_error(ms, errno, "unreadable symlink `%s'", fn);
 			    return -1;
 			}
-			if (mime) {
-				if (handle_mime(ms, mime, "symlink") == -1)
-					return -1;
-			} else if (file_printf(ms,
-			    "%sunreadable symlink `%s' (%s)", COMMA, fn,
-			    strerror(errno)) == -1)
-				return -1;
-			break;
-		}
-		buf[nch] = '\0';	/* readlink(2) does not do this */
-
-		/* If broken symlink, say so and quit early. */
-		if (*buf == '/') {
-			if (stat(buf, &tstatbuf) < 0)
-				return bad_link(ms, errno, buf);
-		} else {
-			char *tmp;
-			char buf2[BUFSIZ+BUFSIZ+4];
-
-			if ((tmp = strrchr(fn,  '/')) == NULL) {
-				tmp = buf; /* in current directory anyway */
-			} else {
-				if (tmp - fn + 1 > BUFSIZ) {
-					if (ms->flags & MAGIC_ERROR) {
-						file_error(ms, 0, 
-						    "path too long: `%s'", buf);
-						return -1;
-					}
-					if (mime) {
-						if (handle_mime(ms, mime,
-						    "x-path-too-long") == -1)
-							return -1;
-					} else if (file_printf(ms,
-					    "%spath too long: `%s'", COMMA,
-					    fn) == -1)
-						return -1;
-					break;
-				}
-				/* take dir part */
-				(void)strlcpy(buf2, fn, sizeof buf2);
-				buf2[tmp - fn + 1] = '\0';
-				/* plus (rel) link */
-				(void)strlcat(buf2, buf, sizeof buf2);
-				tmp = buf2;
-			}
-			if (stat(tmp, &tstatbuf) < 0)
-				return bad_link(ms, errno, buf);
-		}
-
-		/* Otherwise, handle it. */
-		if ((ms->flags & MAGIC_SYMLINK) != 0) {
-			const char *p;
-			ms->flags &= MAGIC_SYMLINK;
-			p = magic_file(ms, buf);
-			ms->flags |= MAGIC_SYMLINK;
-			if (p == NULL)
-				return -1;
-		} else { /* just print what it points to */
-			if (mime) {
-				if (handle_mime(ms, mime, "symlink") == -1)
-					return -1;
-			} else if (file_printf(ms, "%ssymbolic link to `%s'",
-			    COMMA, buf) == -1)
-				return -1;
-		}
-		break;
+	return 1;
 #endif
+
 #ifdef	S_IFSOCK
 #ifndef __COHERENT__
 	case S_IFSOCK:
@@ -348,15 +235,15 @@
 		 * size for raw disk partitions. (If the block special device
 		 * really has zero length, the fact that it is empty will be
 		 * detected and reported correctly when we read the file.)
-		 */
-		if ((ms->flags & MAGIC_DEVICES) == 0 && sb->st_size == 0) {
-			if (mime) {
-				if (handle_mime(ms, mime, "x-empty") == -1)
-					return -1;
-			} else if (file_printf(ms, "%sempty", COMMA) == -1)
+	 */
+	if ((ms->flags & MAGIC_DEVICES) == 0 && sb->st_size == 0) {
+		if (mime) {
+			if (handle_mime(ms, mime, "x-empty") == -1)
 				return -1;
+			} else if (file_printf(ms, "%sempty", COMMA) == -1)
+			return -1;
 			break;
-		}
+	}
 		ret = 0;
 		break;
 
@@ -366,9 +253,5 @@
 		/*NOTREACHED*/
 	}
 
-	if (!mime && did && ret == 0) {
-	    if (file_printf(ms, " ") == -1)
-		    return -1;
-	}
 	return ret;
 }
diff -u libmagic.orig/funcs.c libmagic/funcs.c
--- libmagic.orig/funcs.c	2016-01-25 11:17:38.150978563 +0800
+++ libmagic/funcs.c	2016-01-25 11:19:37.411347842 +0800
@@ -27,7 +27,7 @@
 #include "file.h"
 
 #ifndef	lint
-FILE_RCSID("@(#)$File: funcs.c,v 1.67 2014/02/12 23:20:53 christos Exp $")
+FILE_RCSID("@(#)$File: funcs.c,v 1.68 2014/02/18 11:09:31 kim Exp $")
 #endif	/* lint */
 
 #include "magic.h"
@@ -41,79 +41,79 @@
 #if defined(HAVE_WCTYPE_H)
 #include <wctype.h>
 #endif
-#if defined(HAVE_LIMITS_H)
-#include <limits.h>
-#endif
 #if defined(HAVE_LOCALE_H)
 #include <locale.h>
 #endif
 
 #ifndef SIZE_MAX
-#define SIZE_MAX	((size_t)~0)
+# define SIZE_MAX ((size_t) -1) 
 #endif
 
-/*
- * Like printf, only we append to a buffer.
- */
-protected int
-file_vprintf(struct magic_set *ms, const char *fmt, va_list ap)
-{
-	int len;
-	char *buf, *newstr;
+#include "php.h"
+#include "main/php_network.h"
 
-	if (ms->event_flags & EVENT_HAD_ERR)
-		return 0;
-	len = vasprintf(&buf, fmt, ap);
-	if (len < 0)
-		goto out;
+#ifndef PREG_OFFSET_CAPTURE
+# define PREG_OFFSET_CAPTURE                 (1<<8)
+#endif
 
-	if (ms->o.buf != NULL) {
-		len = asprintf(&newstr, "%s%s", ms->o.buf, buf);
-		free(buf);
-		if (len < 0)
-			goto out;
-		free(ms->o.buf);
-		buf = newstr;
-	}
-	ms->o.buf = buf;
-	return 0;
-out:
-	file_error(ms, errno, "vasprintf failed");
-	return -1;
-}
+extern public void convert_libmagic_pattern(zval *pattern, int options);
 
 protected int
 file_printf(struct magic_set *ms, const char *fmt, ...)
 {
-	int rv;
 	va_list ap;
+	int len;
+	char *buf = NULL, *newstr;
 
 	va_start(ap, fmt);
-	rv = file_vprintf(ms, fmt, ap);
+	len = vspprintf(&buf, 0, fmt, ap);
 	va_end(ap);
-	return rv;
+
+	if (ms->o.buf != NULL) {
+		len = spprintf(&newstr, 0, "%s%s", ms->o.buf, (buf ? buf : ""));
+		if (buf) {
+			efree(buf);
+		}
+		efree(ms->o.buf);
+		ms->o.buf = newstr;
+	} else {
+		ms->o.buf = buf;
+	}
+	return 0;
 }
 
 /*
  * error - print best error message possible
  */
 /*VARARGS*/
-__attribute__((__format__(__printf__, 3, 0)))
 private void
 file_error_core(struct magic_set *ms, int error, const char *f, va_list va,
     size_t lineno)
 {
+	char *buf = NULL;
+	
 	/* Only the first error is ok */
 	if (ms->event_flags & EVENT_HAD_ERR)
 		return;
 	if (lineno != 0) {
-		free(ms->o.buf);
+		efree(ms->o.buf);
 		ms->o.buf = NULL;
 		file_printf(ms, "line %" SIZE_T_FORMAT "u: ", lineno);
 	}
-	file_vprintf(ms, f, va);
-	if (error > 0)
-		file_printf(ms, " (%s)", strerror(error));
+
+	vspprintf(&buf, 0, f, va);
+	va_end(va);
+	
+	if (error > 0) {
+		file_printf(ms, "%s (%s)", (*buf ? buf : ""), strerror(error));
+	} else if (*buf) {
+		file_printf(ms, "%s", buf);
+	}
+	
+	if (buf) {
+		efree(buf);
+	}
+
 	ms->event_flags |= EVENT_HAD_ERR;
 	ms->error = error;
 }
@@ -160,10 +160,9 @@
 	file_error(ms, errno, "error reading");
 }
 
-#ifndef COMPILE_ONLY
 protected int
-file_buffer(struct magic_set *ms, int fd, const char *inname __attribute__ ((unused)),
-    const void *buf, size_t nb)
+file_buffer(struct magic_set *ms, php_stream *stream, const char *inname, const void *buf,
+    size_t nb)
 {
 	int m = 0, rv = 0, looks_text = 0;
 	int mime = ms->flags & MAGIC_MIME;
@@ -174,8 +173,7 @@
 	const char *code_mime = "binary";
 	const char *type = "application/octet-stream";
 	const char *def = "data";
-
-
+	const char *ftype = NULL;
 
 	if (nb == 0) {
 		def = "empty";
@@ -188,7 +186,7 @@
 
 	if ((ms->flags & MAGIC_NO_CHECK_ENCODING) == 0) {
 		looks_text = file_encoding(ms, ubuf, nb, &u8buf, &ulen,
-		    &code, &code_mime, &type);
+		    &code, &code_mime, &ftype);
 	}
 
 #ifdef __EMX__
@@ -203,10 +201,10 @@
 		}
 	}
 #endif
-#if HAVE_FORK
-	/* try compression stuff */
+
+#if PHP_FILEINFO_UNCOMPRESS
 	if ((ms->flags & MAGIC_NO_CHECK_COMPRESS) == 0)
-		if ((m = file_zmagic(ms, fd, inname, ubuf, nb)) != 0) {
+		if ((m = file_zmagic(ms, stream, inname, ubuf, nb)) != 0) {
 			if ((ms->flags & MAGIC_DEBUG) != 0)
 				(void)fprintf(stderr, "zmagic %d\n", m);
 			goto done_encoding;
@@ -221,12 +219,17 @@
 		}
 
 	/* Check if we have a CDF file */
-	if ((ms->flags & MAGIC_NO_CHECK_CDF) == 0)
-		if ((m = file_trycdf(ms, fd, ubuf, nb)) != 0) {
-			if ((ms->flags & MAGIC_DEBUG) != 0)
-				(void)fprintf(stderr, "cdf %d\n", m);
-			goto done;
+	if ((ms->flags & MAGIC_NO_CHECK_CDF) == 0) {
+		php_socket_t fd;
+		TSRMLS_FETCH();
+		if (stream && SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD, (void **)&fd, 0)) {
+			if ((m = file_trycdf(ms, fd, ubuf, nb)) != 0) {
+				if ((ms->flags & MAGIC_DEBUG) != 0)
+					(void)fprintf(stderr, "cdf %d\n", m);
+				goto done;
+			}
 		}
+	}
 
 	/* try soft magic tests */
 	if ((ms->flags & MAGIC_NO_CHECK_SOFT) == 0)
@@ -268,7 +271,7 @@
 		if ((ms->flags & MAGIC_NO_CHECK_ENCODING) == 0) {
 			if (looks_text == 0)
 				if ((m = file_ascmagic_with_encoding( ms, ubuf,
-				    nb, u8buf, ulen, code, type, looks_text))
+				    nb, u8buf, ulen, code, ftype, looks_text))
 				    != 0) {
 					if ((ms->flags & MAGIC_DEBUG) != 0)
 						(void)fprintf(stderr,
@@ -300,7 +303,6 @@
 
 	return m;
 }
-#endif
 
 protected int
 file_reset(struct magic_set *ms)
@@ -310,11 +312,11 @@
 		return -1;
 	}
 	if (ms->o.buf) {
-		free(ms->o.buf);
+		efree(ms->o.buf);
 		ms->o.buf = NULL;
 	}
 	if (ms->o.pbuf) {
-		free(ms->o.pbuf);
+		efree(ms->o.pbuf);
 		ms->o.pbuf = NULL;
 	}
 	ms->event_flags &= ~EVENT_HAD_ERR;
@@ -333,7 +335,7 @@
 protected const char *
 file_getbuffer(struct magic_set *ms)
 {
-	char *pbuf, *op, *np;
+	char *op, *np;
 	size_t psize, len;
 
 	if (ms->event_flags & EVENT_HAD_ERR)
@@ -348,15 +350,13 @@
 	/* * 4 is for octal representation, + 1 is for NUL */
 	len = strlen(ms->o.buf);
 	if (len > (SIZE_MAX - 1) / 4) {
-		file_oomem(ms, len);
 		return NULL;
 	}
 	psize = len * 4 + 1;
-	if ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {
+	if ((ms->o.pbuf = CAST(char *, erealloc(ms->o.pbuf, psize))) == NULL) {
 		file_oomem(ms, psize);
 		return NULL;
 	}
-	ms->o.pbuf = pbuf;
 
 #if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)
 	{
@@ -416,8 +416,8 @@
 	if (level >= ms->c.len) {
 		len = (ms->c.len += 20) * sizeof(*ms->c.li);
 		ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
-		    malloc(len) :
-		    realloc(ms->c.li, len));
+		    emalloc(len) :
+		    erealloc(ms->c.li, len));
 		if (ms->c.li == NULL) {
 			file_oomem(ms, len);
 			return -1;
@@ -437,32 +437,50 @@
 	return ms->o.buf == NULL ? 0 : strlen(ms->o.buf);
 }
 
-protected int
 file_replace(struct magic_set *ms, const char *pat, const char *rep)
 {
-	regex_t rx;
-	int rc, rv = -1;
+	zval *patt;
+	int opts = 0;
+	pcre_cache_entry *pce;
+	char *res;
+	zval *repl;
+	int res_len, rep_cnt = 0;
+	TSRMLS_FETCH();
 
 	(void)setlocale(LC_CTYPE, "C");
-	rc = regcomp(&rx, pat, REG_EXTENDED);
-	if (rc) {
-		char errmsg[512];
-		(void)regerror(rc, &rx, errmsg, sizeof(errmsg));
-		file_magerror(ms, "regex error %d, (%s)", rc, errmsg);
-	} else {
-		regmatch_t rm;
-		int nm = 0;
-		while (regexec(&rx, ms->o.buf, 1, &rm, 0) == 0) {
-			ms->o.buf[rm.rm_so] = '\0';
-			if (file_printf(ms, "%s%s", rep,
-			    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : "") == -1)
-				goto out;
-			nm++;
-		}
-		regfree(&rx);
-		rv = nm;
+
+	MAKE_STD_ZVAL(patt);
+	ZVAL_STRINGL(patt, pat, strlen(pat), 0);
+	opts |= PCRE_MULTILINE;
+	convert_libmagic_pattern(patt, opts);
+	if ((pce = pcre_get_compiled_regex_cache(Z_STRVAL_P(patt), Z_STRLEN_P(patt) TSRMLS_CC)) == NULL) {
+		zval_dtor(patt);
+		FREE_ZVAL(patt);
+		rep_cnt = -1;
+		goto out;
 	}
+
+	MAKE_STD_ZVAL(repl);
+	ZVAL_STRINGL(repl, rep, strlen(rep), 0);
+
+	res = php_pcre_replace_impl(pce, ms->o.buf, strlen(ms->o.buf), repl,
+			0, &res_len, -1, &rep_cnt TSRMLS_CC);
+
+	FREE_ZVAL(repl);
+	zval_dtor(patt);
+	FREE_ZVAL(patt);
+
+	if (NULL == res) {
+		rep_cnt = -1;
+		goto out;
+	}
+
+	strncpy(ms->o.buf, res, res_len);
+	ms->o.buf[res_len] = '\0';
+
+	efree(res);
+
 out:
 	(void)setlocale(LC_CTYPE, "");
-	return rv;
+	return rep_cnt;
 }
Common subdirectories: libmagic.orig/.libs and libmagic/.libs
diff -u libmagic.orig/magic.c libmagic/magic.c
--- libmagic.orig/magic.c	2016-01-25 11:17:38.161978563 +0800
+++ libmagic/magic.c	2016-01-25 11:19:37.411347842 +0800
@@ -25,11 +25,6 @@
  * SUCH DAMAGE.
  */
 
-#ifdef WIN32
-#include <windows.h>
-#include <shlwapi.h>
-#endif
-
 #include "file.h"
 
 #ifndef	lint
@@ -39,15 +34,24 @@
 #include "magic.h"
 
 #include <stdlib.h>
+#ifdef PHP_WIN32
+#include "win32/unistd.h"
+#else
 #include <unistd.h>
+#endif
 #include <string.h>
-#ifdef QUICK
-#include <sys/mman.h>
+#ifdef PHP_WIN32
+# include "config.w32.h"
+#else
+# include "php_config.h"
 #endif
-#ifdef HAVE_LIMITS_H
-#include <limits.h>	/* for PIPE_BUF */
+
+#ifdef PHP_WIN32
+#include <shlwapi.h>
 #endif
 
+#include <limits.h>	/* for PIPE_BUF */
+
 #if defined(HAVE_UTIMES)
 # include <sys/time.h>
 #elif defined(HAVE_UTIME)
@@ -71,18 +75,25 @@
 #endif
 #endif
 
+#ifdef PHP_WIN32
+# undef S_IFLNK
+# undef S_IFIFO
+#endif
+
 private void close_and_restore(const struct magic_set *, const char *, int,
     const struct stat *);
 private int unreadable_info(struct magic_set *, mode_t, const char *);
+#if 0
 private const char* get_default_magic(void);
-#ifndef COMPILE_ONLY
-private const char *file_or_fd(struct magic_set *, const char *, int);
 #endif
+private const char *file_or_stream(struct magic_set *, const char *, php_stream *);
 
 #ifndef	STDIN_FILENO
 #define	STDIN_FILENO	0
 #endif
 
+/* XXX this functionality is excluded in php, enable it in apprentice.c:340 */
+#if 0
 private const char *
 get_default_magic(void)
 {
@@ -90,7 +101,7 @@
 	static char *default_magic;
 	char *home, *hmagicpath;
 
-#ifndef WIN32
+#ifndef PHP_WIN32
 	struct stat st;
 
 	if (default_magic) {
@@ -104,17 +115,17 @@
 		return MAGIC;
 	if (stat(hmagicpath, &st) == -1) {
 		free(hmagicpath);
-		if (asprintf(&hmagicpath, "%s/.magic", home) < 0)
+	if (asprintf(&hmagicpath, "%s/.magic", home) < 0)
+		return MAGIC;
+	if (stat(hmagicpath, &st) == -1)
+		goto out;
+	if (S_ISDIR(st.st_mode)) {
+		free(hmagicpath);
+		if (asprintf(&hmagicpath, "%s/%s", home, hmagic) < 0)
 			return MAGIC;
-		if (stat(hmagicpath, &st) == -1)
+		if (access(hmagicpath, R_OK) == -1)
 			goto out;
-		if (S_ISDIR(st.st_mode)) {
-			free(hmagicpath);
-			if (asprintf(&hmagicpath, "%s/%s", home, hmagic) < 0)
-				return MAGIC;
-			if (access(hmagicpath, R_OK) == -1)
-				goto out;
-		}
+	}
 	}
 
 	if (asprintf(&default_magic, "%s:%s", hmagicpath, MAGIC) < 0)
@@ -128,6 +139,7 @@
 #else
 	char *hmagicp = hmagicpath;
 	char *tmppath = NULL;
+	LPTSTR dllpath;
 
 #define APPENDPATH() \
 	do { \
@@ -172,7 +184,7 @@
 	}
 
 	/* Third, try to get magic file relative to dll location */
-	LPTSTR dllpath = malloc(sizeof(*dllpath) * (MAX_PATH + 1));
+	dllpath = malloc(sizeof(*dllpath) * (MAX_PATH + 1));
 	dllpath[MAX_PATH] = 0;	/* just in case long path gets truncated and not null terminated */
 	if (GetModuleFileNameA(NULL, dllpath, MAX_PATH)){
 		PathRemoveFileSpecA(dllpath);
@@ -210,6 +222,7 @@
 
 	return action == FILE_LOAD ? get_default_magic() : MAGIC;
 }
+#endif
 
 public struct magic_set *
 magic_open(int flags)
@@ -262,13 +275,6 @@
 	return file_apprentice(ms, magicfile, FILE_COMPILE);
 }
 
-public int
-magic_check(struct magic_set *ms, const char *magicfile)
-{
-	if (ms == NULL)
-		return -1;
-	return file_apprentice(ms, magicfile, FILE_CHECK);
-}
 
 public int
 magic_list(struct magic_set *ms, const char *magicfile)
@@ -282,9 +288,6 @@
 close_and_restore(const struct magic_set *ms, const char *name, int fd,
     const struct stat *sb)
 {
-	if (fd == STDIN_FILENO || name == NULL)
-		return;
-	(void) close(fd);
 
 	if ((ms->flags & MAGIC_PRESERVE_ATIME) != 0) {
 		/*
@@ -311,7 +314,6 @@
 	}
 }
 
-#ifndef COMPILE_ONLY
 
 /*
  * find type of descriptor
@@ -321,7 +323,7 @@
 {
 	if (ms == NULL)
 		return NULL;
-	return file_or_fd(ms, NULL, fd);
+	return file_or_stream(ms, NULL, NULL);
 }
 
 /*
@@ -332,31 +334,42 @@
 {
 	if (ms == NULL)
 		return NULL;
-	return file_or_fd(ms, inname, STDIN_FILENO);
+	return file_or_stream(ms, inname, NULL);
+}
+
+public const char *
+magic_stream(struct magic_set *ms, php_stream *stream)
+{
+	if (ms == NULL)
+		return NULL;
+	return file_or_stream(ms, NULL, stream);
 }
 
 private const char *
-file_or_fd(struct magic_set *ms, const char *inname, int fd)
+file_or_stream(struct magic_set *ms, const char *inname, php_stream *stream)
 {
 	int	rv = -1;
 	unsigned char *buf;
 	struct stat	sb;
 	ssize_t nbytes = 0;	/* number of bytes read from a datafile */
-	int	ispipe = 0;
-	off_t	pos = (off_t)-1;
+	int no_in_stream = 0;
+	TSRMLS_FETCH();
+
+	if (!inname && !stream) {
+		return NULL;
+	}
 
 	/*
 	 * one extra for terminating '\0', and
 	 * some overlapping space for matches near EOF
 	 */
 #define SLOP (1 + sizeof(union VALUETYPE))
-	if ((buf = CAST(unsigned char *, malloc(HOWMANY + SLOP))) == NULL)
-		return NULL;
+	buf = emalloc(HOWMANY + SLOP);
 
 	if (file_reset(ms) == -1)
 		goto done;
 
-	switch (file_fsmagic(ms, inname, &sb)) {
+	switch (file_fsmagic(ms, inname, &sb, stream)) {
 	case -1:		/* error */
 		goto done;
 	case 0:			/* nothing found */
@@ -366,74 +379,44 @@
 		goto done;
 	}
 
-	if (inname == NULL) {
-		if (fstat(fd, &sb) == 0 && S_ISFIFO(sb.st_mode))
-			ispipe = 1;
-		else
-			pos = lseek(fd, (off_t)0, SEEK_CUR);
-	} else {
-		int flags = O_RDONLY|O_BINARY;
-		int okstat = stat(inname, &sb) == 0;
+	errno = 0;
 
-		if (okstat && S_ISFIFO(sb.st_mode)) {
-#ifdef O_NONBLOCK
-			flags |= O_NONBLOCK;
-#endif
-			ispipe = 1;
-		}
+	if (!stream && inname) {
+		no_in_stream = 1;
+		stream = php_stream_open_wrapper((char *)inname, "rb", REPORT_ERRORS, NULL);
+	}
 
-		errno = 0;
-		if ((fd = open(inname, flags)) < 0) {
-			if (okstat &&
-			    unreadable_info(ms, sb.st_mode, inname) == -1)
-				goto done;
-			rv = 0;
+	if (!stream) {
+		if (unreadable_info(ms, sb.st_mode, inname) == -1)
 			goto done;
-		}
+		rv = 0;
+		goto done;
+	}
+
 #ifdef O_NONBLOCK
-		if ((flags = fcntl(fd, F_GETFL)) != -1) {
-			flags &= ~O_NONBLOCK;
-			(void)fcntl(fd, F_SETFL, flags);
-		}
+/* we should be already be in non blocking mode for network socket */
 #endif
-	}
 
 	/*
 	 * try looking at the first HOWMANY bytes
 	 */
-	if (ispipe) {
-		ssize_t r = 0;
-
-		while ((r = sread(fd, (void *)&buf[nbytes],
-		    (size_t)(HOWMANY - nbytes), 1)) > 0) {
-			nbytes += r;
-			if (r < PIPE_BUF) break;
-		}
-
-		if (nbytes == 0) {
-			/* We can not read it, but we were able to stat it. */
-			if (unreadable_info(ms, sb.st_mode, inname) == -1)
-				goto done;
-			rv = 0;
-			goto done;
-		}
-
-	} else {
-		if ((nbytes = read(fd, (char *)buf, HOWMANY)) == -1) {
-			file_error(ms, errno, "cannot read `%s'", inname);
-			goto done;
-		}
+	if ((nbytes = php_stream_read(stream, (char *)buf, HOWMANY)) < 0) {
+		file_error(ms, errno, "cannot read `%s'", inname);
+		goto done;
 	}
 
 	(void)memset(buf + nbytes, 0, SLOP); /* NUL terminate */
-	if (file_buffer(ms, fd, inname, buf, (size_t)nbytes) == -1)
+	if (file_buffer(ms, stream, inname, buf, (size_t)nbytes) == -1)
 		goto done;
 	rv = 0;
 done:
-	free(buf);
-	if (pos != (off_t)-1)
-		(void)lseek(fd, pos, SEEK_SET);
-	close_and_restore(ms, inname, fd, &sb);
+	efree(buf);
+
+	if (no_in_stream && stream) {
+		php_stream_close(stream);
+	}
+
+	close_and_restore(ms, inname, 0, &sb);
 	return rv == 0 ? file_getbuffer(ms) : NULL;
 }
 
@@ -447,14 +430,13 @@
 		return NULL;
 	/*
 	 * The main work is done here!
-	 * We have the file name and/or the data buffer to be identified.
+	 * We have the file name and/or the data buffer to be identified. 
 	 */
-	if (file_buffer(ms, -1, NULL, buf, nb) == -1) {
+	if (file_buffer(ms, NULL, NULL, buf, nb) == -1) {
 		return NULL;
 	}
 	return file_getbuffer(ms);
 }
-#endif
 
 public const char *
 magic_error(struct magic_set *ms)
diff -u libmagic.orig/magic.h libmagic/magic.h
--- libmagic.orig/magic.h	2016-01-25 11:17:38.139978563 +0800
+++ libmagic/magic.h	2016-01-25 11:19:37.412347842 +0800
@@ -88,6 +88,7 @@
 
 const char *magic_getpath(const char *, int);
 const char *magic_file(magic_t, const char *);
+const char *magic_stream(magic_t, php_stream *);
 const char *magic_descriptor(magic_t, int);
 const char *magic_buffer(magic_t, const void *, size_t);
 
@@ -97,7 +98,6 @@
 int magic_version(void);
 int magic_load(magic_t, const char *);
 int magic_compile(magic_t, const char *);
-int magic_check(magic_t, const char *);
 int magic_list(magic_t, const char *);
 int magic_errno(magic_t);
 
diff -u libmagic.orig/patchlevel.h libmagic/patchlevel.h
--- libmagic.orig/patchlevel.h	2016-01-25 11:17:38.141978563 +0800
+++ libmagic/patchlevel.h	2016-01-25 11:19:37.412347842 +0800
@@ -351,7 +351,7 @@
  *
  * Revision 1.8  93/02/19  15:01:26  ian
  * Numerous changes from Guy Harris too numerous to mention but including
- * byte-order independance, fixing "old-style masking", etc. etc. A bugfix
+ * byte-order independence, fixing "old-style masking", etc. etc. A bugfix
  * for broken symlinks from martin@@d255s004.zfe.siemens.de.
  * 
  * Revision 1.7  93/01/05  14:57:27  ian
diff -u libmagic.orig/print.c libmagic/print.c
--- libmagic.orig/print.c	2016-01-25 11:17:38.162978563 +0800
+++ libmagic/print.c	2016-01-25 11:19:37.412347842 +0800
@@ -28,13 +28,17 @@
 /*
  * print.c - debugging printout routines
  */
+#define _GNU_SOURCE
+#include "php.h"
 
 #include "file.h"
+#include "cdf.h"
 
 #ifndef lint
 FILE_RCSID("@(#)$File: print.c,v 1.76 2013/02/26 18:25:00 christos Exp $")
 #endif  /* lint */
 
+#include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stdlib.h>
@@ -43,188 +47,31 @@
 #endif
 #include <time.h>
 
-#define SZOF(a)	(sizeof(a) / sizeof(a[0]))
-
-#include "cdf.h"
-
-#ifndef COMPILE_ONLY
-protected void
-file_mdump(struct magic *m)
-{
-	static const char optyp[] = { FILE_OPS };
-	char tbuf[26];
-
-	(void) fprintf(stderr, "%u: %.*s %u", m->lineno,
-	    (m->cont_level & 7) + 1, ">>>>>>>>", m->offset);
-
-	if (m->flag & INDIR) {
-		(void) fprintf(stderr, "(%s,",
-		    /* Note: type is unsigned */
-		    (m->in_type < file_nnames) ? file_names[m->in_type] :
-		    "*bad in_type*");
-		if (m->in_op & FILE_OPINVERSE)
-			(void) fputc('~', stderr);
-		(void) fprintf(stderr, "%c%u),",
-		    ((size_t)(m->in_op & FILE_OPS_MASK) <
-		    SZOF(optyp)) ? optyp[m->in_op & FILE_OPS_MASK] : '?',
-		    m->in_offset);
-	}
-	(void) fprintf(stderr, " %s%s", (m->flag & UNSIGNED) ? "u" : "",
-	    /* Note: type is unsigned */
-	    (m->type < file_nnames) ? file_names[m->type] : "*bad type");
-	if (m->mask_op & FILE_OPINVERSE)
-		(void) fputc('~', stderr);
-
-	if (IS_STRING(m->type)) {
-		if (m->str_flags) {
-			(void) fputc('/', stderr);
-			if (m->str_flags & STRING_COMPACT_WHITESPACE) 
-				(void) fputc(CHAR_COMPACT_WHITESPACE, stderr);
-			if (m->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) 
-				(void) fputc(CHAR_COMPACT_OPTIONAL_WHITESPACE,
-				    stderr);
-			if (m->str_flags & STRING_IGNORE_LOWERCASE) 
-				(void) fputc(CHAR_IGNORE_LOWERCASE, stderr);
-			if (m->str_flags & STRING_IGNORE_UPPERCASE) 
-				(void) fputc(CHAR_IGNORE_UPPERCASE, stderr);
-			if (m->str_flags & REGEX_OFFSET_START) 
-				(void) fputc(CHAR_REGEX_OFFSET_START, stderr);
-			if (m->str_flags & STRING_TEXTTEST)
-				(void) fputc(CHAR_TEXTTEST, stderr);
-			if (m->str_flags & STRING_BINTEST)
-				(void) fputc(CHAR_BINTEST, stderr);
-			if (m->str_flags & PSTRING_1_BE)
-				(void) fputc(CHAR_PSTRING_1_BE, stderr);
-			if (m->str_flags & PSTRING_2_BE)
-				(void) fputc(CHAR_PSTRING_2_BE, stderr);
-			if (m->str_flags & PSTRING_2_LE)
-				(void) fputc(CHAR_PSTRING_2_LE, stderr);
-			if (m->str_flags & PSTRING_4_BE)
-				(void) fputc(CHAR_PSTRING_4_BE, stderr);
-			if (m->str_flags & PSTRING_4_LE)
-				(void) fputc(CHAR_PSTRING_4_LE, stderr);
-			if (m->str_flags & PSTRING_LENGTH_INCLUDES_ITSELF)
-				(void) fputc(
-				    CHAR_PSTRING_LENGTH_INCLUDES_ITSELF,
-				    stderr);
-		}
-		if (m->str_range)
-			(void) fprintf(stderr, "/%u", m->str_range);
-	}
-	else {
-		if ((size_t)(m->mask_op & FILE_OPS_MASK) < SZOF(optyp))
-			(void) fputc(optyp[m->mask_op & FILE_OPS_MASK], stderr);
-		else
-			(void) fputc('?', stderr);
-			
-		if (m->num_mask) {
-			(void) fprintf(stderr, "%.8llx",
-			    (unsigned long long)m->num_mask);
-		}
-	}
-	(void) fprintf(stderr, ",%c", m->reln);
-
-	if (m->reln != 'x') {
-		switch (m->type) {
-		case FILE_BYTE:
-		case FILE_SHORT:
-		case FILE_LONG:
-		case FILE_LESHORT:
-		case FILE_LELONG:
-		case FILE_MELONG:
-		case FILE_BESHORT:
-		case FILE_BELONG:
-		case FILE_INDIRECT:
-			(void) fprintf(stderr, "%d", m->value.l);
-			break;
-		case FILE_BEQUAD:
-		case FILE_LEQUAD:
-		case FILE_QUAD:
-			(void) fprintf(stderr, "%" INT64_T_FORMAT "d",
-			    (unsigned long long)m->value.q);
-			break;
-		case FILE_PSTRING:
-		case FILE_STRING:
-		case FILE_REGEX:
-		case FILE_BESTRING16:
-		case FILE_LESTRING16:
-		case FILE_SEARCH:
-			file_showstr(stderr, m->value.s, (size_t)m->vallen);
-			break;
-		case FILE_DATE:
-		case FILE_LEDATE:
-		case FILE_BEDATE:
-		case FILE_MEDATE:
-			(void)fprintf(stderr, "%s,",
-			    file_fmttime(m->value.l, FILE_T_LOCAL, tbuf));
-			break;
-		case FILE_LDATE:
-		case FILE_LELDATE:
-		case FILE_BELDATE:
-		case FILE_MELDATE:
-			(void)fprintf(stderr, "%s,",
-			    file_fmttime(m->value.l, 0, tbuf));
-		case FILE_QDATE:
-		case FILE_LEQDATE:
-		case FILE_BEQDATE:
-			(void)fprintf(stderr, "%s,",
-			    file_fmttime(m->value.q, FILE_T_LOCAL, tbuf));
-			break;
-		case FILE_QLDATE:
-		case FILE_LEQLDATE:
-		case FILE_BEQLDATE:
-			(void)fprintf(stderr, "%s,",
-			    file_fmttime(m->value.q, 0, tbuf));
-			break;
-		case FILE_QWDATE:
-		case FILE_LEQWDATE:
-		case FILE_BEQWDATE:
-			(void)fprintf(stderr, "%s,",
-			    file_fmttime(m->value.q, FILE_T_WINDOWS, tbuf));
-			break;
-		case FILE_FLOAT:
-		case FILE_BEFLOAT:
-		case FILE_LEFLOAT:
-			(void) fprintf(stderr, "%G", m->value.f);
-			break;
-		case FILE_DOUBLE:
-		case FILE_BEDOUBLE:
-		case FILE_LEDOUBLE:
-			(void) fprintf(stderr, "%G", m->value.d);
-			break;
-		case FILE_DEFAULT:
-			/* XXX - do anything here? */
-			break;
-		case FILE_USE:
-		case FILE_NAME:
-			(void) fprintf(stderr, "'%s'", m->value.s);
-			break;
-		default:
-			(void) fprintf(stderr, "*bad type %d*", m->type);
-			break;
-		}
-	}
-	(void) fprintf(stderr, ",\"%s\"]\n", m->desc);
-}
+#ifdef PHP_WIN32
+# define asctime_r php_asctime_r
+# define ctime_r php_ctime_r
 #endif
 
+#define SZOF(a)	(sizeof(a) / sizeof(a[0]))
+
 /*VARARGS*/
 protected void
 file_magwarn(struct magic_set *ms, const char *f, ...)
 {
 	va_list va;
+	char *expanded_format = NULL;
+	int expanded_len;
+	TSRMLS_FETCH();
 
-	/* cuz we use stdout for most, stderr here */
-	(void) fflush(stdout); 
-
-	if (ms->file)
-		(void) fprintf(stderr, "%s, %lu: ", ms->file,
-		    (unsigned long)ms->line);
-	(void) fprintf(stderr, "Warning: ");
 	va_start(va, f);
-	(void) vfprintf(stderr, f, va);
+	expanded_len = vasprintf(&expanded_format, f, va);
 	va_end(va);
-	(void) fputc('\n', stderr);
+	
+	if (expanded_len >= 0 && expanded_format) {
+		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Warning: %s", expanded_format);
+
+		free(expanded_format);
+	}
 }
 
 protected const char *
@@ -235,7 +82,7 @@
 	struct tm *tm;
 
 	if (flags & FILE_T_WINDOWS) {
-		struct timespec ts;
+		struct timeval ts;
 		cdf_timestamp_to_timespec(&ts, t);
 		t = ts.tv_sec;
 	}
diff -u libmagic.orig/readcdf.c libmagic/readcdf.c
--- libmagic.orig/readcdf.c	2016-01-25 11:17:38.160978563 +0800
+++ libmagic/readcdf.c	2016-01-25 11:19:37.412347842 +0800
@@ -26,11 +26,15 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: readcdf.c,v 1.37 2014/01/06 13:41:18 rrt Exp $")
+FILE_RCSID("@(#)$File: readcdf.c,v 1.40 2014/03/06 15:23:33 christos Exp $")
 #endif
 
 #include <stdlib.h>
+#ifdef PHP_WIN32
+#include "win32/unistd.h"
+#else
 #include <unistd.h>
+#endif
 #include <string.h>
 #include <time.h>
 #include <ctype.h>
@@ -69,6 +73,50 @@
 	{ NULL,				NULL,			},
 };
 
+#ifdef PHP_WIN32
+# define strcasestr strstr
+#endif
+
+static const struct cv {
+	uint64_t clsid[2];
+	const char *mime;
+} clsid2mime[] = {
+	{
+#ifdef PHP_WIN32
+		{ 0x00000000000c1084ui64, 0x46000000000000c0ui64 },
+#else
+		{ 0x00000000000c1084LLU, 0x46000000000000c0LLU },
+#endif
+		"x-msi",
+	},
+	{	{ 0,			 0			},
+		NULL,
+	}
+}, clsid2desc[] = {
+	{
+#ifdef PHP_WIN32
+		{ 0x00000000000c1084ui64, 0x46000000000000c0ui64 },
+#else
+		{ 0x00000000000c1084LLU, 0x46000000000000c0LLU },
+#endif
+		"MSI Installer",
+	},
+	{	{ 0,			 0			},
+		NULL,
+	}
+};
+
+private const char *
+cdf_clsid_to_mime(const uint64_t clsid[2], const struct cv *cv)
+{
+	size_t i;
+	for (i = 0; cv[i].mime != NULL; i++) {
+		if (clsid[0] == cv[i].clsid[0] && clsid[1] == cv[i].clsid[1])
+			return cv[i].mime;
+	}
+	return NULL;
+}
+
 private const char *
 cdf_app_to_mime(const char *vbuf, const struct nv *nv)
 {
@@ -87,16 +135,21 @@
 
 private int
 cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,
-    size_t count)
+    size_t count, const cdf_directory_t *root_storage)
 {
         size_t i;
         cdf_timestamp_t tp;
-        struct timespec ts;
+        struct timeval ts;
         char buf[64];
         const char *str = NULL;
         const char *s;
         int len;
 
+	memset(&ts, 0, sizeof(ts));
+
+        if (!NOTMIME(ms) && root_storage)
+		str = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2mime);
+
         for (i = 0; i < count; i++) {
                 cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);
                 switch (info[i].pi_type) {
@@ -153,7 +206,7 @@
                                                     buf, vbuf) == -1)
                                                         return -1;
                                         }
-                                } else if (info[i].pi_id ==
+                                } else if (str == NULL && info[i].pi_id ==
 				    CDF_PROPERTY_NAME_OF_APPLICATION) {
 					str = cdf_app_to_mime(vbuf, app2mime);
 				}
@@ -162,8 +215,12 @@
                 case CDF_FILETIME:
                         tp = info[i].pi_tp;
                         if (tp != 0) {
-				char tbuf[64];
-                                if (tp < 1000000000000000LL) {
+							char tbuf[64];
+#if defined(PHP_WIN32) && _MSC_VER <= 1500
+							if (tp < 1000000000000000i64) {
+#else
+							if (tp < 1000000000000000LL) {
+#endif
                                         cdf_print_elapsed_time(tbuf,
                                             sizeof(tbuf), tp);
                                         if (NOTMIME(ms) && file_printf(ms,
@@ -171,8 +228,11 @@
                                                 return -1;
                                 } else {
                                         char *c, *ec;
-                                        cdf_timestamp_to_timespec(&ts, tp);
-                                        c = cdf_ctime(&ts.tv_sec, tbuf);
+					const time_t sec = ts.tv_sec;
+                                        if (cdf_timestamp_to_timespec(&ts, tp) == -1) {
+											return -1;
+										}
+                                        c = cdf_ctime(&sec, tbuf);
                                         if (c != NULL &&
 					    (ec = strchr(c, '\n')) != NULL)
 						*ec = '\0';
@@ -200,7 +260,7 @@
 
 private int
 cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,
-    const cdf_stream_t *sst)
+    const cdf_stream_t *sst, const cdf_directory_t *root_storage)
 {
         cdf_summary_info_header_t si;
         cdf_property_info_t *info;
@@ -211,6 +271,8 @@
                 return -1;
 
         if (NOTMIME(ms)) {
+		const char *str;
+
                 if (file_printf(ms, "Composite Document File V2 Document")
 		    == -1)
                         return -1;
@@ -238,9 +300,15 @@
                                 return -2;
                         break;
                 }
-        }
+		if (root_storage) {
+			str = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);
+			if (str)
+				if (file_printf(ms, ", %s", str) == -1)
+					return -2;
+			}
+		}
 
-        m = cdf_file_property_info(ms, info, count);
+        m = cdf_file_property_info(ms, info, count, root_storage);
         free(info);
 
         return m == -1 ? -2 : m;
@@ -258,6 +326,7 @@
         int i;
         const char *expn = "";
         const char *corrupt = "corrupt: ";
+        const cdf_directory_t *root_storage;
 
         info.i_fd = fd;
         info.i_buf = buf;
@@ -291,7 +360,8 @@
                 goto out2;
         }
 
-        if ((i = cdf_read_short_stream(&info, &h, &sat, &dir, &sst)) == -1) {
+        if ((i = cdf_read_short_stream(&info, &h, &sat, &dir, &sst,
+	    &root_storage)) == -1) {
                 expn = "Cannot read short stream";
                 goto out3;
         }
@@ -312,23 +382,21 @@
 #ifdef CDF_DEBUG
         cdf_dump_summary_info(&h, &scn);
 #endif
-        if ((i = cdf_file_summary_info(ms, &h, &scn)) < 0)
-                expn = "Can't expand summary_info";
+        if ((i = cdf_file_summary_info(ms, &h, &scn, root_storage)) < 0)
+            expn = "Can't expand summary_info";
+
 	if (i == 0) {
 		const char *str = NULL;
 		cdf_directory_t *d;
 		char name[__arraycount(d->d_name)];
 		size_t j, k;
-		for (j = 0; j < dir.dir_len; j++) {
+
+		for (j = 0; str == NULL && j < dir.dir_len; j++) {
 			d = &dir.dir_tab[j];
 			for (k = 0; k < sizeof(name); k++)
 				name[k] = (char)cdf_tole2(d->d_name[k]);
-			if (NOTMIME(ms))
-				str = cdf_app_to_mime(name, name2desc);
-			else
-				str = cdf_app_to_mime(name, name2mime);
-			if (str != NULL)
-				break;
+			str = cdf_app_to_mime(name,
+			    NOTMIME(ms) ? name2desc : name2mime);
 		}
 		if (NOTMIME(ms)) {
 			if (str != NULL) {
Only in libmagic.orig/: readelf.c
Only in libmagic.orig/: readelf.h
diff -u libmagic.orig/softmagic.c libmagic/softmagic.c
--- libmagic.orig/softmagic.c	2016-01-25 11:17:38.139978563 +0800
+++ libmagic/softmagic.c	2016-01-25 11:19:45.545347848 +0800
@@ -50,6 +50,11 @@
 #include <locale.h>
 #endif
 
+#ifndef PREG_OFFSET_CAPTURE
+# define PREG_OFFSET_CAPTURE                 (1<<8)
+#endif
+
+
 
 private int match(struct magic_set *, struct magic *, uint32_t,
     const unsigned char *, size_t, size_t, int, int, int, int, int *, int *,
@@ -62,7 +67,7 @@
 private int32_t moffset(struct magic_set *, struct magic *);
 private void mdebug(uint32_t, const char *, size_t);
 private int mcopy(struct magic_set *, union VALUETYPE *, int, int,
-    const unsigned char *, uint32_t, size_t, size_t);
+    const unsigned char *, uint32_t, size_t, struct magic *);
 private int mconvert(struct magic_set *, struct magic *, int);
 private int print_sep(struct magic_set *, int);
 private int handle_annotation(struct magic_set *, struct magic *);
@@ -71,7 +76,8 @@
 private void cvt_32(union VALUETYPE *, const struct magic *);
 private void cvt_64(union VALUETYPE *, const struct magic *);
 
-#define OFFSET_OOB(n, o, i)	((n) < (o) || (i) >= ((n) - (o)))
+#define OFFSET_OOB(n, o, i)	((n) < (o) || (i) > ((n) - (o)))
+
 /*
  * softmagic - lookup one file in parsed, in-memory copy of database
  * Passed the name and FILE * of one file to be typed.
@@ -142,7 +148,7 @@
 		struct magic *m = &magic[magindex];
 
 		if (m->type != FILE_NAME)
-		if ((IS_STRING(m->type) &&
+		if ((IS_LIBMAGIC_STRING(m->type) &&
 #define FLT (STRING_BINTEST | STRING_TEXTTEST)
 		     ((text && (m->str_flags & FLT) == STRING_BINTEST) ||
 		      (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||
@@ -221,8 +227,8 @@
 		if (file_check_mem(ms, ++cont_level) == -1)
 			return -1;
 
-		while (magic[magindex+1].cont_level != 0 &&
-		    ++magindex < nmagic) {
+		while (magindex + 1 < nmagic && magic[magindex+1].cont_level != 0 &&
+		    ++magindex) {
 			m = &magic[magindex];
 			ms->line = m->lineno; /* for messages */
 
@@ -350,46 +356,24 @@
 private int
 check_fmt(struct magic_set *ms, struct magic *m)
 {
-	regex_t rx;
-	int rc, rv = -1;
-
+	pcre *pce;
+	int re_options, rv = -1;
+	pcre_extra *re_extra;
+	TSRMLS_FETCH();
+	
 	if (strchr(m->desc, '%') == NULL)
 		return 0;
 
 	(void)setlocale(LC_CTYPE, "C");
-	rc = regcomp(&rx, "%[-0-9\\.]*s", REG_EXTENDED|REG_NOSUB);
-	if (rc) {
-		char errmsg[512];
-		(void)regerror(rc, &rx, errmsg, sizeof(errmsg));
-		file_magerror(ms, "regex error %d, (%s)", rc, errmsg);
+	if ((pce = pcre_get_compiled_regex("~%[-0-9.]*s~", &re_extra, &re_options TSRMLS_CC)) == NULL) {
+		rv = -1;
 	} else {
-		rc = regexec(&rx, m->desc, 0, 0, 0);
-		regfree(&rx);
-		rv = !rc;
+	 	rv = !pcre_exec(pce, re_extra, m->desc, strlen(m->desc), 0, re_options, NULL, 0);
 	}
 	(void)setlocale(LC_CTYPE, "");
 	return rv;
 }
 
-#ifndef HAVE_STRNDUP
-char * strndup(const char *, size_t);
-
-char *
-strndup(const char *str, size_t n)
-{
-	size_t len;
-	char *copy;
-
-	for (len = 0; len < n && str[len]; len++)
-		continue;
-	if ((copy = malloc(len + 1)) == NULL)
-		return NULL;
-	(void)memcpy(copy, str, len);
-	copy[len] = '\0';
-	return copy;
-}
-#endif /* HAVE_STRNDUP */
-
 private int32_t
 mprint(struct magic_set *ms, struct magic *m)
 {
@@ -618,13 +602,13 @@
 		char *cp;
 		int rval;
 
-		cp = strndup((const char *)ms->search.s, ms->search.rm_len);
+		cp = estrndup((const char *)ms->search.s, ms->search.rm_len);
 		if (cp == NULL) {
 			file_oomem(ms, ms->search.rm_len);
 			return -1;
 		}
 		rval = file_printf(ms, F(m->desc, "%s"), cp);
-		free(cp);
+		efree(cp);
 
 		if (rval == -1)
 			return -1;
@@ -870,16 +854,16 @@
 	if (m->num_mask) \
 		switch (m->mask_op & FILE_OPS_MASK) { \
 		case FILE_OPADD: \
-			p->fld += cast m->num_mask; \
+			p->fld += cast (int64_t)m->num_mask; \
 			break; \
 		case FILE_OPMINUS: \
-			p->fld -= cast m->num_mask; \
+			p->fld -= cast (int64_t)m->num_mask; \
 			break; \
 		case FILE_OPMULTIPLY: \
-			p->fld *= cast m->num_mask; \
+			p->fld *= cast (int64_t)m->num_mask; \
 			break; \
 		case FILE_OPDIVIDE: \
-			p->fld /= cast m->num_mask; \
+			p->fld /= cast (int64_t)m->num_mask; \
 			break; \
 		} \
 
@@ -931,10 +915,21 @@
 		return 1;
 	}
 	case FILE_PSTRING: {
-		char *ptr1 = p->s, *ptr2 = ptr1 + file_pstring_length_size(m);
+		size_t sz = file_pstring_length_size(m);
+		char *ptr1 = p->s, *ptr2 = ptr1 + sz;
 		size_t len = file_pstring_get_length(m, ptr1);
-		if (len >= sizeof(p->s))
-			len = sizeof(p->s) - 1;
+		sz = sizeof(p->s) - sz; /* maximum length of string */
+		if (len >= sz) {
+			/*
+			 * The size of the pascal string length (sz)
+			 * is 1, 2, or 4. We need at least 1 byte for NUL
+			 * termination, but we've already truncated the
+			 * string by p->s, so we need to deduct sz.
+			 * Because we can use one of the bytes of the length
+			 * after we shifted as NUL termination.
+			 */ 
+			len = sz;
+		}
 		while (len--)
 			*ptr1++ = *ptr2++;
 		*ptr1 = '\0';
@@ -1046,7 +1041,7 @@
 
 private int
 mcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,
-    const unsigned char *s, uint32_t offset, size_t nbytes, size_t linecnt)
+    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)
 {
 	/*
 	 * Note: FILE_SEARCH and FILE_REGEX do not actually copy
@@ -1066,15 +1061,27 @@
 			const char *last;	/* end of search region */
 			const char *buf;	/* start of search region */
 			const char *end;
-			size_t lines;
+			size_t lines, linecnt, bytecnt;
+
+			linecnt = m->str_range;
+			bytecnt = linecnt * 80;
 
+			if (bytecnt == 0) {
+				bytecnt = 8192;
+			}
+			if (bytecnt > nbytes) {
+				bytecnt = nbytes;
+			}
+			if (offset > bytecnt) {
+				offset = bytecnt;
+			}
 			if (s == NULL) {
 				ms->search.s_len = 0;
 				ms->search.s = NULL;
 				return 0;
 			}
 			buf = RCAST(const char *, s) + offset;
-			end = last = RCAST(const char *, s) + nbytes;
+			end = last = RCAST(const char *, s) + bytecnt;
 			/* mget() guarantees buf <= last */
 			for (lines = linecnt, b = buf; lines && b < end &&
 			     ((b = CAST(const char *,
@@ -1087,7 +1094,7 @@
 					b++;
 			}
 			if (lines)
-				last = RCAST(const char *, s) + nbytes;
+				last = RCAST(const char *, s) + bytecnt;
 
 			ms->search.s = buf;
 			ms->search.s_len = last - buf;
@@ -1158,7 +1165,6 @@
     int *need_separator, int *returnval)
 {
 	uint32_t soffset, offset = ms->offset;
-	uint32_t count = m->str_range;
 	int rv, oneed_separator, in_type;
 	char *sbuf, *rbuf;
 	union VALUETYPE *p = &ms->ms_value;
@@ -1170,17 +1176,13 @@
 	}
 
 	if (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),
-	    (uint32_t)nbytes, count) == -1)
+	    (uint32_t)nbytes, m) == -1)
 		return -1;
 
 	if ((ms->flags & MAGIC_DEBUG) != 0) {
 		fprintf(stderr, "mget(type=%d, flag=%x, offset=%u, o=%zu, "
-		    "nbytes=%zu, count=%u)\n", m->type, m->flag, offset, o,
-		    nbytes, count);
+		    "nbytes=%zu)\n", m->type, m->flag, offset, o, nbytes);
 		mdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));
-#ifndef COMPILE_ONLY
-		file_mdump(m);
-#endif
 	}
 
 	if (m->flag & INDIR) {
@@ -1672,16 +1674,13 @@
 			if ((ms->flags & MAGIC_DEBUG) != 0)
 				fprintf(stderr, "indirect +offs=%u\n", offset);
 		}
-		if (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)
+		if (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)
 			return -1;
 		ms->offset = offset;
 
 		if ((ms->flags & MAGIC_DEBUG) != 0) {
 			mdebug(offset, (char *)(void *)p,
 			    sizeof(union VALUETYPE));
-#ifndef COMPILE_ONLY
-			file_mdump(m);
-#endif
 		}
 	}
 
@@ -1755,11 +1754,21 @@
 		ms->offset = soffset;
 		if (rv == 1) {
 			if ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&
-			    file_printf(ms, F(m->desc, "%u"), offset) == -1)
+			    file_printf(ms, m->desc, offset) == -1) {
+				if (rbuf) {
+					efree(rbuf);
+				}
 				return -1;
-			if (file_printf(ms, "%s", rbuf) == -1)
+			}
+			if (file_printf(ms, "%s", rbuf) == -1) {
+				if (rbuf) {
+					efree(rbuf);
+				}
 				return -1;
-			free(rbuf);
+			}
+		}
+		if (rbuf) {
+			efree(rbuf);
 		}
 		return rv;
 
@@ -1875,6 +1884,42 @@
 	return file_strncmp(a, b, len, flags);
 }
 
+public void
+convert_libmagic_pattern(zval *pattern, int options)
+{
+		int i, j=0;
+		char *t;
+
+		t = (char *) safe_emalloc(Z_STRLEN_P(pattern), 2, 5);
+		
+		t[j++] = '~';
+		
+		for (i=0; i<Z_STRLEN_P(pattern); i++, j++) {
+			switch (Z_STRVAL_P(pattern)[i]) {
+				case '~':
+					t[j++] = '\\';
+					t[j] = '~';
+					break;
+				default:
+					t[j] = Z_STRVAL_P(pattern)[i];
+					break;
+			}
+		}
+		t[j++] = '~';
+	
+		if (options & PCRE_CASELESS) 
+			t[j++] = 'i';
+	
+		if (options & PCRE_MULTILINE)
+			t[j++] = 'm';
+
+		t[j]='\0';
+	
+		Z_STRVAL_P(pattern) = t;
+		Z_STRLEN_P(pattern) = j;
+
+}
+
 private int
 magiccheck(struct magic_set *ms, struct magic *m)
 {
@@ -2035,63 +2080,90 @@
 		break;
 	}
 	case FILE_REGEX: {
-		int rc;
-		regex_t rx;
-		char errmsg[512];
-
-		if (ms->search.s == NULL)
-			return 0;
-
-		l = 0;
-		rc = regcomp(&rx, m->value.s,
-		    REG_EXTENDED|REG_NEWLINE|
-		    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));
-		if (rc) {
-			(void)regerror(rc, &rx, errmsg, sizeof(errmsg));
-			file_magerror(ms, "regex error %d, (%s)",
-			    rc, errmsg);
-			v = (uint64_t)-1;
-		}
-		else {
-			regmatch_t pmatch[1];
-#ifndef REG_STARTEND
-#define	REG_STARTEND	0
-			size_t l = ms->search.s_len - 1;
-			char c = ms->search.s[l];
-			((char *)(intptr_t)ms->search.s)[l] = '\0';
-#else
-			pmatch[0].rm_so = 0;
-			pmatch[0].rm_eo = ms->search.s_len;
-#endif
-			rc = regexec(&rx, (const char *)ms->search.s,
-			    1, pmatch, REG_STARTEND);
-#if REG_STARTEND == 0
-			((char *)(intptr_t)ms->search.s)[l] = c;
-#endif
-			switch (rc) {
-			case 0:
-				ms->search.s += (int)pmatch[0].rm_so;
-				ms->search.offset += (size_t)pmatch[0].rm_so;
-				ms->search.rm_len =
-				    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);
-				v = 0;
-				break;
-
-			case REG_NOMATCH:
+		zval *pattern;
+		int options = 0;
+		pcre_cache_entry *pce;
+		TSRMLS_FETCH();
+		
+		MAKE_STD_ZVAL(pattern);
+		ZVAL_STRINGL(pattern, (char *)m->value.s, m->vallen, 0);
+	
+		options |= PCRE_MULTILINE;
+		
+		if (m->str_flags & STRING_IGNORE_CASE) {
+			options |= PCRE_CASELESS;
+		}
+		
+		convert_libmagic_pattern(pattern, options);
+		
+		l = v = 0;
+		if ((pce = pcre_get_compiled_regex_cache(Z_STRVAL_P(pattern), Z_STRLEN_P(pattern) TSRMLS_CC)) == NULL) {
+			zval_dtor(pattern);
+			FREE_ZVAL(pattern);
+			return -1;
+		} else {
+			/* pce now contains the compiled regex */
+			zval *retval;
+			zval *subpats;
+			char *haystack;
+
+			MAKE_STD_ZVAL(retval);
+			ALLOC_INIT_ZVAL(subpats);
+			
+			/* Cut the search len from haystack, equals to REG_STARTEND */
+			haystack = estrndup(ms->search.s, ms->search.s_len);
+
+			/* match v = 0, no match v = 1 */
+			php_pcre_match_impl(pce, haystack, ms->search.s_len, retval, subpats, 0, 1, PREG_OFFSET_CAPTURE, 0 TSRMLS_CC);
+			/* Free haystack */
+			efree(haystack);
+			
+			if (Z_LVAL_P(retval) < 0) {
+				zval_ptr_dtor(&subpats);
+				FREE_ZVAL(retval);
+				zval_dtor(pattern);
+				FREE_ZVAL(pattern);
+				return -1;
+			} else if ((Z_LVAL_P(retval) > 0) && (Z_TYPE_P(subpats) == IS_ARRAY)) {
+				/* Need to fetch global match which equals pmatch[0] */
+				zval **ppzval;
+				HashTable *ht = Z_ARRVAL_P(subpats);
+				/* The first element (should be) is the global match 
+				   Need to move to the inner array to get the global match */
+				if (zend_hash_index_find(ht, 0, (void **)&ppzval) == SUCCESS) {
+					zval **match, **offset;
+					/* If everything goes according to the master plan
+					   tmpcopy now contains two elements:
+					   0 = the match
+					   1 = starting position of the match */
+					if (zend_hash_index_find(Z_ARRVAL_PP(ppzval), 0, (void **)&match) == SUCCESS 
+							&& zend_hash_index_find(Z_ARRVAL_PP(ppzval), 1, (void **)&offset) == SUCCESS) {
+						if (Z_TYPE_PP(match) != IS_STRING || Z_TYPE_PP(offset) != IS_LONG) {
+							goto error_out;
+						}
+						ms->search.s += (int)Z_LVAL_PP(offset); /* this is where the match starts */
+						ms->search.offset += (size_t)Z_LVAL_PP(offset); /* this is where the match starts as size_t */
+						ms->search.rm_len = Z_STRLEN_PP(match) /* This is the length of the matched pattern */;
+						v = 0;
+					} else {
+						goto error_out;
+					}
+				} else {
+error_out:
+					zval_ptr_dtor(&subpats);
+					FREE_ZVAL(retval);
+					zval_dtor(pattern);
+					FREE_ZVAL(pattern);
+					return -1;
+				}
+			} else {
 				v = 1;
-				break;
-
-			default:
-				(void)regerror(rc, &rx, errmsg, sizeof(errmsg));
-				file_magerror(ms, "regexec error %d, (%s)",
-				    rc, errmsg);
-				v = (uint64_t)-1;
-				break;
 			}
-			regfree(&rx);
+			zval_ptr_dtor(&subpats);
+			FREE_ZVAL(retval);
 		}
-		if (v == (uint64_t)-1)
-			return -1;
+		zval_dtor(pattern);
+		FREE_ZVAL(pattern);
 		break;
 	}
 	case FILE_INDIRECT:
diff -u libmagic.orig/strcasestr.c libmagic/strcasestr.c
--- libmagic.orig/strcasestr.c	2016-01-25 11:17:38.160978563 +0800
+++ libmagic/strcasestr.c	2016-01-25 11:19:37.413347842 +0800
@@ -37,6 +37,8 @@
 __RCSID("$NetBSD: strncasecmp.c,v 1.2 2007/06/04 18:19:27 christos Exp $");
 #endif /* LIBC_SCCS and not lint */
 
+#include "php_stdint.h"
+
 #include <assert.h>
 #include <ctype.h>
 #include <string.h>
